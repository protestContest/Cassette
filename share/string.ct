module String
import IO

let newline = 0x0A
let space = 0x20
let tab = 0x09

def (space? char) char == space
def (newline? char) char == newline
def (tab? char) char == tab
def (whitespace? char) (space? char) or (newline? char) or (tab? char)

def (split str a b) do
  head (Type.split-bin (tail (Type.split-bin str a)) b)
end

def (slice str start length) [str, start, length]
def (slice? value) do
  cond do
    (Type.typeof value) != :pair -> false
    #value != 3 -> false
    (Type.typeof value.0) != :binary -> false
    (Type.typeof value.1) != :integer -> false
    (Type.typeof value.2) != :integer -> false
    value.1 < 0 -> false
    value.2 < 0 -> false
    value.1 + value.2 > #value.0 -> false
    true -> true
  end
end

def (match test str) do
  def (loop index) do
    cond do
      index == #test -> true
      test.(index) != str.(index) -> false
      true -> loop index + 1
    end
  end

  loop 0
end

def (digit? c) c >= $0 and c <= $9

def (parse-int str) do
  def (loop index num str) do
    cond do
      index == #str -> num | index
      str.(index) == $_ -> loop index + 1 num str
      not (digit? str.(index)) -> num | index
      true -> do
        let digit = str.(index) - $0
        loop index + 1 num * 10 + digit str
      end
    end
  end

  def (parse index str) do
    if str.(index) == $- do
      let parsed = loop index + 1 0 str
      -(head parsed) | (tail parsed)
    else
      loop index 0 str
    end
  end

  cond do
    (Type.typeof str) == :binary -> parse 0 str
    (slice? str) -> parse str.1 str.0
    true -> panic! "Expected a string or string slice"
  end
end

def (parse-float str) do
  def (loop index whole frac exp) do
    cond do
      index == #str -> whole + frac / exp | index
      not (digit? str.(index)) -> whole + frac / exp | index
      true -> do
        let digit = str.(index) - $0
        loop index + 1 whole frac * 10 + digit exp * 10
      end
    end
  end

  let int = parse-int str,
      index = (tail int),
      whole = (head int)

  if index < #str and str.(index) == $. do
    loop index + 1 whole 0 1
  else
    int
  end
end
