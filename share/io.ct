module IO
import List
import Result as *
import String
import Type

let console = (try! (Device.open :console {}))

def (num-str n) do
  def (loop n str) do
    if n == 0 do
      Type.join-bin str
    else
      let d = n % 10 + $0
      loop (Type.trunc n / 10) d | str
    end
  end

  if n == 0 do
    "0"
  else
    loop n nil
  end
end

def (format iodata) (Type.join-bin iodata)

def (printable? data) do
  def (printable-binary? data index) cond do
    index == #data -> true
    not (printable? data.(index)) -> false
    true -> printable-binary? data index + 1
  end

  cond do
    (Type.typeof data) == :binary -> printable-binary? data 0
    (Type.typeof data) == :integer -> data >= 0 and data < 256
    (Type.typeof data) == :pair -> List.all? data printable?
    true -> false
  end
end

def (print data) do
  def (loop data length) do
    if (Type.typeof data) == :pair do
      List.reduce data length loop
    else
      try! (Device.write console data)
    end
  end

  cond do
    (Type.typeof data) == :integer -> print (num-str data)
    not (printable? data) -> do
      print ["Unprintable value", String.newline]
      :error
    end
    true -> do
      let length = loop data 0
      if length > 0 do
        Device.write console String.newline
      end
      :ok
    end
  end
end

def (write data) (Device.write console data)

def (read-line) do
  try! (Device.read console 1024)
end

def (inspect value) do
  cond do
    (Type.typeof value) == :integer -> print value
    (Type.typeof value) == :float -> print "Float"
    (Type.typeof value) == :pair -> print "Pair"
    (Type.typeof value) == :tuple -> print "Tuple"
    (Type.typeof value) == :binary -> print value
    (Type.typeof value) == :map -> print "Map"
    (Type.typeof value) == :symbol -> print [":", Type.symbol-name value]
    true -> print "Unknown value"
  end
end
