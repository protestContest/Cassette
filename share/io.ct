module IO
import List
import Type

let console = (unwrap! (Device.open :console {}))

def (read-line) do
  unwrap! (Device.read console 1024)
end

def (format iodata) (Type.join-bin iodata)

def (inspect value depth) do
  def (inspect-int num acc) do
    if num == 0 do
      if acc == nil do
        "0"
      else
        acc
      end
    else
      let d = $0 + num % 10
      inspect-int (Type.trunc num / 10) d | acc
    end
  end

  def (inspect-num num) do
    if (Type.typeof num) == :integer do
      (inspect-int num nil)
    else
      let whole = inspect-int (Type.trunc num) nil,
          part = inspect-int (Type.trunc (num - (Type.trunc num)) * 1000) nil
      [whole, ".", part]
    end
  end

  def (inspect-list list) do
    ; let items = List.map \item -> (inspect item depth - 1) value
    ; ["[", List.intersperse ", " items, "]"]
    inspect (head list) depth - 1
  end

  def (inspect-tuple tuple) do
    let items = List.map \item -> (inspect item depth - 1) (List.from tuple)
    ["{", List.intersperse ", " items, "}"]
  end

  def (inspect-entry entry) do
    let key = head entry, value = tail entry
    if (Type.typeof key) == :symbol do
      [Type.symbol-name key, ": ", inspect value depth - 1]
    else
      [inspect key depth - 1, " => ", inspect value depth - 1]
    end
  end

  def (inspect-map map) do
    let items = List.map inspect-entry (List.from map)
    ["{", List.intersperse ", " items, "}"]
  end

  cond do
    depth == 0 -> "..."
    (Type.typeof value) == :integer -> inspect-num value
    (Type.typeof value) == :float -> inspect-num value
    (Type.typeof value) == :pair -> inspect-list value
    (Type.typeof value) == :tuple -> inspect-tuple value
    (Type.typeof value) == :binary -> value
    (Type.typeof value) == :map -> inspect-map value
    (Type.typeof value) == :symbol -> [":", Type.symbol-name value]
    true -> "<???>"
  end
end

def (print value) do
  Device.write console (format [(inspect value 3), 0x0A])
end
