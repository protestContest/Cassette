module Enum

def (reduce enum acc fn) do
  def (reduce_list list acc fn) do
    if list == nil do
      acc
    else
      reduce (tail list) (fn (head list) acc) fn
    end
  end

  def (reduce_tuple tuple acc fn) do
    def (loop i acc) do
      if i == #tuple do
        acc
      else
        loop i+1 (fn tuple.i acc)
      end
    end

    loop 0 acc
  end

  cond do
    (pair? enum) -> reduce_list enum acc fn
    (tuple? enum) -> reduce_tuple enum acc fn
  end
end

def (reverse enum) do
  cond do
    (pair? enum)  -> List.reverse enum
    (tuple? enum) -> (List.to_tuple (List.reverse (Tuple.to_list enum)))
  end
end

def (map enum fn) do
  reduce (reverse enum) [] (item acc) -> (fn item) | acc
end

def (each enum fn) do
  if enum == nil do
    :ok
  else
    (fn (head enum))
    (each (tail enum) fn)
  end
end

def (filter enum fn) do
  reduce enum [] (item acc) ->
    if (fn item) do
      item | acc
    else
      acc
    end
end

def (iota n) do
  def (loop m acc) do
    if m == n do
      List.reverse acc
    else
      loop m + 1 m | acc
    end
  end

  loop 0 []
end

def (index_of item tuple) do
  def (loop n) do
    cond do
      n == #tuple         -> nil
      (tuple n) == item   -> n
      true                -> loop n + 1
    end
  end

  loop 0
end

let record = fields -> do
  elements -> do
    (field) -> do
      elements (index_of field fields)
    end
  end
end
