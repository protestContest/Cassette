module IO
import List, Value
export open, close, read, write, seek, print, inspect, read_file, write_file, error?, nl

let nl = 0x0A

def open(path, modes) do
  def parse_modes(modes) do
    let read = List.contains?(modes, :read),
        write = List.contains?(modes, :write),
        append = List.contains?(modes, :append),
        excl = List.contains?(modes, :exclusive)

    let flags =
      cond
        read and (write or append or excl) -> 2 ;read-write
        write or append or excl -> 1 ;write
        true -> 0 ;read
      end

    let flags = if write or append or excl do flags ^ 512 else flags end, ;create
        flags = if append do flags ^ 8 else flags end, ;append
        flags = if write and not read do flags ^ 1024 else flags end, ;trunc
        flags = if excl do flags ^ 2048 else flags end ;excl

    flags
  end

  trap(:open, path, parse_modes(modes))
end

def close(file) trap(:close, file)

def read(file, size) trap(:read, file, size)
def write(file, data) trap(:write, file, data, #data)
def print(str) write(0, Value.format([str, nl]))
def inspect(val) print(Value.inspect(val))
def seek(file, offset, whence) do
  let whence =
    cond
      whence == :start -> 0
      whence == :cur -> 1
      whence == :end -> 2
      true -> 0
    end
  trap(:seek, file, offset, whence)
end

def read_file(path) do
  let file = open(path, :read)
  if error?(file) do
    file
  else
    let size = seek(file, 0, :end)
    seek(file, 0, :start)
    let contents = read(file, size)
    close(file)
    contents
  end
end

def write_file(path, data) do
  let file = open(path, :write)
  if file do
    let written = write(file, data)
    close(file)
    written
  else
    0
  end
end

def error?(result) do
  Value.typeof(result) == :tuple and #result > 0 and result[0] == :error
end
