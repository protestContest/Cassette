#!/usr/bin/env gsi-script

(define Rule (struct '(Rule lhs rhs)))

(define (rule-part->str part)
  (cond
    ((string? part) (enclose part "\""))
    (else (to-string part))))

(define (rule-syms rule) (rule 'rhs))

(define (print-rule rule)
  (let ((padding (- 16 (string-length (symbol->string (rule 'lhs))))))
    (display (rule 'lhs))
    (display (repeat " " padding))
    (display "→ ")
    (if (nil? (rule 'rhs))
        (display "ε")
        (display
          (join (map (rule 'rhs) (lambda (part)
            (cond
              ((string? part) (enclose part "\""))
              (else (symbol->string part)))))
            " ")))))

(define Grammar (struct '(Grammar rules terminals nonterminals) (lambda (rules)
  (let* ((nonterms (unique (map rules (lambda (r) (r 'lhs)))))
         (syms (unique (flat-map rules (lambda (r) (rule-syms r)))))
         (terms (reject syms (lambda (sym) (in-list? sym nonterms)))))
    (list rules terms nonterms)))))

(define (rules-for sym grammar) (filter (grammar 'rules) (lambda (rule) (equal? sym (rule 'lhs)))))
(define (rule-id rule grammar) (++ (index-of rule (grammar 'rules))))
; (define (grammar-rule id grammar) (nth (-- id) (grammar 'rules)))
; (define (terminal? sym grammar) (in-list? sym (grammar 'terminals)))
(define (nonterminal? sym grammar) (in-list? sym (grammar 'nonterminals)))
(define (top-symbol grammar) ((first (grammar 'rules)) 'lhs))
(define (symbols-in grammar) (append (grammar 'terminals) (grammar 'nonterminals)))

(define (print-grammar grammar)
  (each (grammar 'rules)
        (lambda (rule) (let ((i (rule-id rule grammar)))
          (display (repeat " " (- 3 (number-length i))))
          (display i)
          (display " ")
          (print-rule rule)
          (newline)))))

(define (read-grammar filename)
  (define (epsilon? char)     (and (char? char) (char=? char #\ε)))
  (define (arrow? char)       (and (char? char) (char=? char #\→)))
  (define (quote? char)       (and (char? char) (char=? char #\")))
  (define (bar? char)         (and (char? char) (char=? char #\|)))

  (define (skip-char)         (read-char) (skip-whitespace))
  (define (skip-line)
    (read-char)
    (if (not (newline? (peek-char))) (skip-line)))
  (define (skip-whitespace)
    (cond
      ((whitespace? (peek-char)) (skip-char))
      ((comment? (peek-char)) (skip-line))))

  (define (skip-empty-lines n)
    (skip-whitespace)
    (if (newline? (peek-char))
        (begin (skip-char) (skip-empty-lines (++ n)) n)
        n))

  (define (read-sym)
    (define (sym-loop str)
      (if (or (whitespace? (peek-char))
              (newline? (peek-char))
              (eof-object? (peek-char)))
          (string->symbol str)
          (sym-loop (string-append str (string (read-char))))))
    (sym-loop ""))

  (define (read-str)
    (define (str-loop str)
      (if (quote? (peek-char))
          (begin (skip-char) str)
          (str-loop (string-append str (string (read-char))))))
    (read-char)
    (str-loop ""))

  (define (read-rule-part)
    (skip-whitespace)
    (cond
      ((quote? (peek-char)) (read-str))
      (else (read-sym))))

  (define (read-rhs lhs)
    (define (rhs-loop2 rules)
      (skip-whitespace)
      (cond
        ((eof-object? (peek-char)) rules)
        ((newline? (peek-char)) rules)
        ((bar? (peek-char))
          (begin (skip-char) (rhs-loop2 rules)))
        (else (rhs-loop2 (pair (rhs-loop '()) rules)))))

    (define (rhs-loop rhs)
      (skip-whitespace)
      (cond
        ((eof-object? (peek-char)) (Rule lhs (reverse rhs)))
        ((newline? (peek-char)) (Rule lhs (reverse rhs)))
        ((bar? (peek-char)) (Rule lhs (reverse rhs)))
        ((epsilon? (peek-char)) (begin (skip-char) (rhs-loop rhs)))
        (else (rhs-loop (pair (read-rule-part) rhs)))))
    (rhs-loop2 '()))

  (define (read-rule line)
    (skip-whitespace)
    (let ((lhs (read-sym)))
      (skip-whitespace)
      (if (not (arrow? (peek-char)))
        (error "Expected \"→\" after rule left-hand-side on line" line))
      (skip-char)
      (read-rhs lhs)))

  (define (loop rules line)
    (let ((line (skip-empty-lines line)))
      (if (eof-object? (peek-char))
          (reverse rules)
          (loop (append (read-rule line) rules) line))))

  (with-input-from-file filename (lambda ()
    (let* ((rules (loop '() 1))
           (top-sym ((first rules) 'lhs))
           (top-rule (Rule 'program (list top-sym '$))))
    (Grammar (pair top-rule rules))))))

; Parser generator

(define Config (struct '(Config rule position)))
(define (next-sym config) (nth (config 'position) (rule-syms (config 'rule))))
(define (config-final? config) (= (config 'position) (length (rule-syms (config 'rule)))))
(define (advance-config config)
  (if (config-final? config)
      config
      (Config (config 'rule) (++ (config 'position)))))
(define (configs-equal? config1 config2)
  (and (equal? (config1 'rule) (config2 'rule))
       (equal? (config1 'position) (config2 'position))))

(define State (struct '(State id configs successors)))

(define Reduction (struct '(Reduction id sym num rule) (lambda (rule grammar)
  (let ((id (rule-id rule grammar))
        (num (length (rule 'rhs))))
    (list id (rule 'lhs) num rule)))))

(define Parser (struct '(Parser grammar states actions reductions) (lambda (grammar)
  (define (successor sym configs grammar)
    (closure (map configs advance-config) grammar))

  (define (closure configs grammar)
    (let* ((syms (unique (map configs next-sym)))
           (syms (filter syms (lambda (sym) (nonterminal? sym grammar))))
           (rules (flat-map syms (lambda (sym) (rules-for sym grammar))))
           (new-configs (map rules (lambda (rule) (Config rule 0))))
           (new-configs (reject new-configs (lambda (config) (in-list? config configs configs-equal?)))))
      (if (empty? new-configs)
          configs
          (closure (append configs new-configs) grammar))))

  (define (grammar-states grammar)
    (define (start-state grammar)
      (let* ((rules (rules-for (top-symbol grammar) grammar))
             (configs (map rules (lambda (rule) (Config rule 0))))
             (configs (closure configs grammar)))
        (State 0 configs '())))

    (define (find-state configs states)
      (find states (lambda (state)
        (and (= (length configs) (length (state 'configs)))
             (all? configs (lambda (config)
                  (in-list? config (state 'configs) configs-equal?)))))))

    (define (loop states queue)
      (define (gen-successors sym-set acc)
        (let* ((sym (head sym-set))
               (configs (tail sym-set))
               (successors (first acc))
               (queue (second acc))
               (next-id (third acc))
               (state (either (find-state configs states)
                              (find-state configs queue))))
          (if (nil? state)
              (let ((state (State next-id configs '())))
                (list (keylist-set successors sym next-id)
                      (pair state queue)
                      (++ next-id)))
              (list (keylist-set successors sym (state 'id))
                    queue
                    next-id))))

        (let* ((next-id (+ (length states) (length queue)))
               (state (head queue))
               (queue (tail queue))
               (configs (reject (state 'configs) config-final?))
               (by-sym (group-by configs (lambda (config) (next-sym config))))
               (sets (map by-sym (lambda (sym-configs)
                        (let ((sym (head sym-configs)) (configs (tail sym-configs)))
                          (pair sym (successor sym configs grammar))))))
               (succ-queue (reduce sets (list '() (reverse queue) next-id) gen-successors))
               (successors (first succ-queue))
               (queue (reverse (second succ-queue)))
               (state (State (state 'id) (state 'configs) (reverse successors))))
          (if (empty? queue)
              (reverse (pair state states))
              (loop (pair state states) queue))))

    (loop '() (list (start-state grammar))))

  (define (action-table states)
    (map (sort states (lambda (s1 s2) (s1 'id) < (s2 'id)))
         (lambda (state)
            (map (symbols-in grammar) (lambda (sym)
              (pair sym (keylist-get (state 'successors) sym)))))))

  (define (reduction-table states)
    (map states (lambda (state)
      (let ((configs (filter (state 'configs) config-final?)))
        (cond
          ((nil? configs) (pair (state 'id) nil))
          ((= (length configs) 1)
            (pair (state 'id) (Reduction ((head configs) 'rule) grammar)))
          (else
            (error "Reduce conflict in" (state 'id))))))))

  (let ((states (grammar-states grammar)))
    (list grammar
          states
          (action-table states)
          (reduction-table states))))))

(define (print-config config)
  (define (format-parts parts)
    (map parts (lambda (part) (rule-part->str part))))

  (let* ((rule (config 'rule))
         (padding (- 16 (string-length (symbol->string (rule 'lhs))))))
    (display (rule 'lhs))
    (display (repeat " " padding))
    (display "→ ")
    (if (nil? (rule 'rhs))
        (display "ε")
        (let* ((split (split-at (rule 'rhs) (config 'position)))
               (before (head split))
               (after (tail split)))
          (display
            (join
              (append (format-parts before)
                      (list "·")
                      (format-parts after))
              " "))))))

(define (print-state state reduction)
  (display (join (list "State" (state 'id)) " "))
  (newline)
  (each (state 'configs) (lambda (config)
    (display "  ")
    (print-config config)
    (newline)))
  (if (not (nil? (state 'successors)))
    (let ((longest-sym (max-in (map (map (map (state 'successors) head) to-string) string-length))))
      (each (state 'successors) (lambda (sym-succ)
        (let* ((sym (head sym-succ))
               (sym (if (string? sym) (enclose sym "\"") (to-string sym)))
               (succ (tail sym-succ))
               (padding (- longest-sym (string-length (to-string sym)))))
          (display "    On ")
          (display sym)
          (display (repeat " " padding))
          (display " → ")
          (display succ)
          (newline))))))
  (if (not (nil? reduction))
    (begin
      (display "    Reduce ")
      (display (reduction 'id))
      (display " (")
      (display (reduction 'sym))
      (display ", ")
      (display (reduction 'num))
      (display ")")
      (newline))))

(define (print-parse-states parser)
  (each (parser 'states) (lambda (state)
    (let ((reduction (keylist-get (parser 'reductions) (state 'id))))
      (print-state state reduction)
      (newline)))))

(define (print-parse-syms parser)
  (define (snake->camel str)
    (define (loop chars acc)
      (cond
        ((nil? chars)
          acc)
        ((nil? acc)
          (loop (tail chars) (cons (char-upcase (head chars)) acc)))
        ((char=? (head chars) #\_)
          (loop (tail (tail chars)) (cons (char-upcase (head (tail chars))) acc)))
        (else
          (loop (tail chars) (cons (head chars) acc)))))
    (list->string (reverse (loop (string->list str) '()))))

  (define (parse-sym-name sym)
    (cond
      ((eq? sym '$) "EOF")
      ((and (string? sym) (string=? sym "$")) "EOF")
      ((and (string? sym) (string=? sym "\\n")) "NL")
      ((and (string? sym) (string=? sym "+")) "Plus")
      ((and (string? sym) (string=? sym "-")) "Minus")
      ((and (string? sym) (string=? sym "*")) "Star")
      ((and (string? sym) (string=? sym "/")) "Slash")
      ((and (string? sym) (string=? sym "(")) "LParen")
      ((and (string? sym) (string=? sym ")")) "RParen")
      ((and (string? sym) (string=? sym "->")) "Arrow")
      ((and (string? sym) (string=? sym "=")) "Equal")
      ((and (string? sym) (string=? sym "==")) "EqualEqual")
      ((and (string? sym) (string=? sym "!=")) "NotEqual")
      ((and (string? sym) (string=? sym "|")) "Bar")
      ((and (string? sym) (string=? sym "<")) "LessThan")
      ((and (string? sym) (string=? sym "<=")) "LessEqual")
      ((and (string? sym) (string=? sym ">")) "GreaterThan")
      ((and (string? sym) (string=? sym ">=")) "GreaterEqual")
      ((and (string? sym) (string=? sym ":")) "Colon")
      ((and (string? sym) (string=? sym "::")) "ColonColon")
      ((and (string? sym) (string=? sym "#[")) "HashBracket")
      ((and (string? sym) (string=? sym "[")) "LBracket")
      ((and (string? sym) (string=? sym "]")) "RBracket")
      ((and (string? sym) (string=? sym "{")) "LBrace")
      ((and (string? sym) (string=? sym "}")) "RBrace")
      ((and (string? sym) (string=? sym ",")) "Comma")
      ((and (string? sym) (string=? sym ".")) "Dot")
      (else (snake->camel (to-string sym)))))

  (display "#pragma once")
  (newline)
  (newline)
  (display "enum {")
  (newline)
  (each (symbols-in (parser 'grammar)) (lambda (sym)
    (display "  ")
    (display "ParseSym")
    (display (parse-sym-name sym))
    (display ",")
    (newline)))
  (display "};")
  (newline)
  (newline))

(define (print-parse-tables parser)
  (define (print-row row size)
    (each row (lambda (item)
      (let* ((item (if (nil? item) "NULL" (to-string item)))
             (padding (- size (string-length item))))
        (display (repeat " " padding))
        (display item)
        (display ",")))))

  (define (chunk-size items max)
    (++ (div (length items) (++ (div (length items) max)))))

  (display "#pragma once")
  (newline)
  (newline)
  (display "/*")
  (newline)
  (display "Grammar:")
  (newline)
  (print-grammar (parser 'grammar))
  (display "*/")
  (newline)
  (newline)

  (display "#define NUM_STATES ")
  (display (length (parser 'states)))
  (newline)
  (display "#define NUM_SYMS ")
  (display (length (symbols-in (parser 'grammar))))
  (newline)
  (display "#define TOP_SYMBOL ")
  (display (index-of (top-symbol (parser 'grammar)) (symbols-in (parser 'grammar))))
  (newline)
  (display "#define NUM_LITERALS ")
  (display (length (filter ((parser 'grammar) 'terminals) string?)))
  (newline)
  (newline)

  (display "char *symbol_names[] = {")
  (newline)
  (each (with-index (symbols-in (parser 'grammar))) (lambda (isym)
    (display "  [")
    (display (head isym))
    (display "] = \"")
    (display (tail isym))
    (display "\",")
    (newline)))
  (display "};")
  (newline)
  (newline)

  (display "static _unused struct {char *lexeme; u8 symbol;} literals[] = {")
  (newline)
  (each (sort (filter (with-index (symbols-in (parser 'grammar))) (lambda (isym)
                      (string? (tail isym))))
              (lambda (isym1 isym2)
                (> (string-length (tail isym1)) (string-length (tail isym2)))))
        (lambda (isym)
          (display "  { ")
          (display (enclose (tail isym) "\""))
          (display ", ")
          (display (head isym))
          (display " },")
          (newline)))
  (display "};")
  (newline)
  (newline)

  (let* ((reductions (map (parser 'reductions) tail))
         (ids (map reductions
                  (lambda (reduction)
                    (if (nil? reduction) -1
                        (index-of (reduction 'sym)
                                  (symbols-in (parser 'grammar)))))))
         (lengths (map reductions
                       (lambda (reduction)
                         (if (nil? reduction) 0 (reduction 'num))))))
    (display "// indexed by state")
    (newline)
    (display "static _unused i8 reduction_syms[] = {")
    (newline)

    ; (++ (div (length ids) 16))
    (each (chunk-every ids (chunk-size ids 20)) (lambda (chunk)
      (print-row chunk 4)
      (newline)))
    (display "};")
    (newline)
    (newline)
    (display "// indexed by state")
    (newline)
    (display "static _unused u8 reduction_sizes[] = {")
    (newline)
    (each (chunk-every lengths (chunk-size ids 20)) (lambda (chunk)
      (print-row chunk 4)
      (newline)))
    (display "};")
    (newline))
  (newline)

  (display "// indexed by state, symbol")
  (newline)
  (display "static _unused i16 actions[][NUM_SYMS] = {")
  (newline)
  (let ((rows (map (parser 'actions)
                   (lambda (items)
                      (map items (lambda (item) (either (tail item) -1)))))))
    (each rows (lambda (row)
      (let ((chunks (chunk-every row (chunk-size row 24))))
        (display "  {")
        (print-row (head chunks) 4)
        (each (tail chunks) (lambda (chunk)
          (newline)
          (display "   ")
          (print-row chunk 4)))
        (display "},")
        (newline))))
    (display "};")
    (newline)))

; Script

(let* ((grammar-file (second (command-line)))
       (output-file (either (third (command-line)) "../src/parse_table.h"))
       (symbols-file (either (fourth (command-line)) "../src/parse_syms.h"))
       (grammar (read-grammar grammar-file))
       (parser (Parser grammar)))
  (with-output-to-file output-file (lambda () (print-parse-tables parser)))
  (with-output-to-file symbols-file (lambda () (print-parse-syms parser)))
  (with-output-to-file "grammar/parse_states.txt" (lambda () (print-parse-states parser))))
