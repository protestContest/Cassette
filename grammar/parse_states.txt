  0 program     →  stmts $
  1 stmts       →  stmts stmt NL
  2 stmts       →  NL
  3 stmts       →  ε
  4 stmt        →  let_stmt
  5 stmt        →  def_stmt
  6 stmt        →  call
  7 let_stmt    →  "let" assigns
  8 assigns     →  assigns "," assign
  9 assigns     →  assign
 10 assign      →  ID "=" call
 11 def_stmt    →  "def" "(" id_list ")" arg
 12 id_list     →  id_list ID
 13 id_list     →  ID
 14 call        →  call arg
 15 call        →  arg
 16 arg         →  lambda
 17 lambda      →  ID "->" logic
 18 lambda      →  group "->" logic
 19 lambda      →  "(" ")" "->" logic
 20 lambda      →  logic
 21 logic       →  logic "and" equals
 22 logic       →  logic "or" equals
 23 logic       →  equals
 24 equals      →  compare "==" compare
 25 equals      →  compare "!=" compare
 26 equals      →  compare
 27 compare     →  member ">" member
 28 compare     →  member ">=" member
 29 compare     →  member "<" member
 30 compare     →  member "<=" member
 31 compare     →  member
 32 member      →  sum "in" sum
 33 member      →  sum
 34 sum         →  sum "+" product
 35 sum         →  sum "-" product
 36 sum         →  product
 37 product     →  product "*" unary
 38 product     →  product "/" unary
 39 product     →  unary
 40 unary       →  "not" primary
 41 unary       →  primary
 42 primary     →  NUM
 43 primary     →  ID
 44 primary     →  STR
 45 primary     →  literal
 46 primary     →  symbol
 47 primary     →  access
 48 primary     →  group
 49 primary     →  block
 50 primary     →  object
 51 literal     →  "true"
 52 literal     →  "false"
 53 literal     →  "nil"
 54 symbol      →  ":" ID
 55 access      →  access "." ID
 56 access      →  ID "." ID
 57 group       →  "(" call ")"
 58 block       →  do_block
 59 block       →  if_block
 60 block       →  cond_block
 61 do_block    →  "do" stmts "end"
 62 if_block    →  "if" arg do_else
 63 if_block    →  "if" arg do_block nothing
 64 do_else     →  "do" stmts "else" stmts "end"
 65 cond_block  →  "cond" "do" clauses "end"
 66 clauses     →  clauses clause
 67 clauses     →  NL
 68 clauses     →  ε
 69 clause      →  logic "->" call NL
 70 object      →  list
 71 object      →  tuple
 72 object      →  map
 73 list        →  "[" items "]"
 74 tuple       →  "#[" items "]"
 75 map         →  "{" entries "}"
 76 items       →  items item
 77 items       →  ε
 78 item        →  arg opt_comma
 79 entries     →  entries entry
 80 entries     →  ε
 81 entry       →  ID ":" arg opt_comma
 82 opt_comma   →  ","
 83 opt_comma   →  NL
 84 opt_comma   →  ε
 85 nothing     →  ε
  0 program
    First: NL 
    Follow: 
  1 stmts
    First: NL 
    Follow: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "def" "#[" "not" $ "end" "let" "else" "nil" NUM "true" 
  2 stmt
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "def" "#[" "not" "let" "nil" NUM "true" 
    Follow: NL 
  3 let_stmt
    First: "let" 
    Follow: NL 
  4 assigns
    First: ID 
    Follow: NL "," 
  5 assign
    First: ID 
    Follow: NL "," 
  6 def_stmt
    First: "def" 
    Follow: NL 
  7 id_list
    First: ID 
    Follow: ")" ID 
  8 call
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
  9 arg
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 10 lambda
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 11 logic
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "and" "false" ID "[" "#[" "not" "nil" NUM "->" "true" "or" 
 12 equals
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "and" "false" ID "[" "#[" "not" "nil" NUM "->" "true" "or" 
 13 compare
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" "==" ":" "do" ")" STR "and" "false" ID "[" "#[" "not" "nil" "!=" NUM "->" "true" "or" 
 14 member
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "{" NL "cond" ">" "do" "and" "false" "[" "not" "nil" ">=" NUM "or" "(" "<" "if" "," "==" ":" ")" STR ID "#[" "<=" "!=" "->" "true" 
 15 sum
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "#[" "<=" "!=" "->" "true" 
 16 product
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 17 unary
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 18 primary
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "nil" NUM "true" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 19 literal
    First: "false" "nil" "true" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 20 symbol
    First: ":" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 21 access
    First: ID 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "." "->" "true" 
 22 group
    First: "(" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 23 block
    First: "if" "cond" "do" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 24 do_block
    First: "do" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 25 if_block
    First: "if" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 26 do_else
    First: "do" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 27 cond_block
    First: "cond" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 28 clauses
    First: NL 
    Follow: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "end" "nil" NUM "true" 
 29 clause
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "end" "nil" NUM "true" 
 30 object
    First: "{" "[" "#[" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 31 list
    First: "[" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 32 tuple
    First: "#[" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 33 map
    First: "{" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 34 items
    First: 
    Follow: "]" "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 35 item
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "]" "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 36 entries
    First: 
    Follow: "}" ID 
 37 entry
    First: ID 
    Follow: "}" ID 
 38 opt_comma
    First: NL "," 
    Follow: "]" "(" "{" "if" "cond" ":" "do" "}" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 39 nothing
    First: 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 40 $
 41 NL
 42 "let"
 43 ","
 44 ID
 45 "="
 46 "def"
 47 "("
 48 ")"
 49 "->"
 50 "and"
 51 "or"
 52 "=="
 53 "!="
 54 ">"
 55 ">="
 56 "<"
 57 "<="
 58 "in"
 59 "+"
 60 "-"
 61 "*"
 62 "/"
 63 "not"
 64 NUM
 65 STR
 66 "true"
 67 "false"
 68 "nil"
 69 ":"
 70 "."
 71 "do"
 72 "end"
 73 "if"
 74 "else"
 75 "cond"
 76 "["
 77 "]"
 78 "#["
 79 "{"
 80 "}"
Shift/reduce conflict in state 32 for "->": shift 74 vs shift 18
Shift/reduce conflict in state 35 for "->": shift 76 vs shift 18
State 0
  program    → • stmts $
  stmts      → • stmts stmt NL
  stmts      → • NL
  stmts      → ε •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On NL         shift to state 1
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On stmts      shift to state 2
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 1
  stmts      → NL •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 2
  program    → stmts • $
  stmts      → stmts • stmt NL
  stmt       → • let_stmt
  stmt       → • def_stmt
  stmt       → • call
  let_stmt   → • "let" assigns
  def_stmt   → • "def" "(" id_list ")" arg
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On literal    shift to state 3
  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On let_stmt   shift to state 13
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On def        shift to state 17
  On not        shift to state 18
  On call       shift to state 19
  On if_block   shift to state 20
  On let        shift to state 21
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On $          shift to state 39
  On lambda     shift to state 40
  On cond_block shift to state 41
  On def_stmt   shift to state 42
  On block      shift to state 43
  On tuple      shift to state 44
  On stmt       shift to state 45
  On true       shift to state 46

State 3
  primary    → literal •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 4
  member     → sum • "in" sum
  member     → sum •
  sum        → sum • "+" product
  sum        → sum • "-" product

  On {          reduce rule 14 (member)
  On NL         reduce rule 14 (member)
  On in         shift to state 48
  On cond       reduce rule 14 (member)
  On >          reduce rule 14 (member)
  On do         reduce rule 14 (member)
  On and        reduce rule 14 (member)
  On false      reduce rule 14 (member)
  On [          reduce rule 14 (member)
  On not        reduce rule 14 (member)
  On +          shift to state 49
  On nil        reduce rule 14 (member)
  On >=         reduce rule 14 (member)
  On NUM        reduce rule 14 (member)
  On or         reduce rule 14 (member)
  On -          shift to state 47
  On (          reduce rule 14 (member)
  On <          reduce rule 14 (member)
  On if         reduce rule 14 (member)
  On ,          reduce rule 14 (member)
  On ==         reduce rule 14 (member)
  On :          reduce rule 14 (member)
  On )          reduce rule 14 (member)
  On STR        reduce rule 14 (member)
  On ID         reduce rule 14 (member)
  On #[         reduce rule 14 (member)
  On <=         reduce rule 14 (member)
  On !=         reduce rule 14 (member)
  On ->         reduce rule 14 (member)
  On true       reduce rule 14 (member)

State 5
  map        → "{" • entries "}"
  entries    → • entries entry
  entries    → ε •

  On }          reduce rule 36 (entries)
  On ID         reduce rule 36 (entries)
  On entries    shift to state 50

State 6
  block      → do_block •

  On /          reduce rule 23 (block)
  On {          reduce rule 23 (block)
  On NL         reduce rule 23 (block)
  On in         reduce rule 23 (block)
  On cond       reduce rule 23 (block)
  On >          reduce rule 23 (block)
  On do         reduce rule 23 (block)
  On and        reduce rule 23 (block)
  On false      reduce rule 23 (block)
  On [          reduce rule 23 (block)
  On not        reduce rule 23 (block)
  On +          reduce rule 23 (block)
  On nil        reduce rule 23 (block)
  On >=         reduce rule 23 (block)
  On NUM        reduce rule 23 (block)
  On or         reduce rule 23 (block)
  On -          reduce rule 23 (block)
  On (          reduce rule 23 (block)
  On <          reduce rule 23 (block)
  On if         reduce rule 23 (block)
  On ,          reduce rule 23 (block)
  On ==         reduce rule 23 (block)
  On :          reduce rule 23 (block)
  On )          reduce rule 23 (block)
  On STR        reduce rule 23 (block)
  On ID         reduce rule 23 (block)
  On *          reduce rule 23 (block)
  On #[         reduce rule 23 (block)
  On <=         reduce rule 23 (block)
  On !=         reduce rule 23 (block)
  On ->         reduce rule 23 (block)
  On true       reduce rule 23 (block)

State 7
  lambda     → logic •
  logic      → logic • "and" equals
  logic      → logic • "or" equals

  On (          reduce rule 10 (lambda)
  On {          reduce rule 10 (lambda)
  On NL         reduce rule 10 (lambda)
  On if         reduce rule 10 (lambda)
  On ,          reduce rule 10 (lambda)
  On cond       reduce rule 10 (lambda)
  On :          reduce rule 10 (lambda)
  On do         reduce rule 10 (lambda)
  On )          reduce rule 10 (lambda)
  On STR        reduce rule 10 (lambda)
  On and        shift to state 51
  On false      reduce rule 10 (lambda)
  On ID         reduce rule 10 (lambda)
  On [          reduce rule 10 (lambda)
  On #[         reduce rule 10 (lambda)
  On not        reduce rule 10 (lambda)
  On nil        reduce rule 10 (lambda)
  On NUM        reduce rule 10 (lambda)
  On true       reduce rule 10 (lambda)
  On or         shift to state 52

State 8
  cond_block → "cond" • "do" clauses "end"

  On do         shift to state 53

State 9
  primary    → symbol •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 10
  do_block   → "do" • stmts "end"
  stmts      → • stmts stmt NL
  stmts      → • NL
  stmts      → ε •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On NL         shift to state 1
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On stmts      shift to state 54
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 11
  sum        → product •
  product    → product • "*" unary
  product    → product • "/" unary

  On /          shift to state 55
  On {          reduce rule 15 (sum)
  On NL         reduce rule 15 (sum)
  On in         reduce rule 15 (sum)
  On cond       reduce rule 15 (sum)
  On >          reduce rule 15 (sum)
  On do         reduce rule 15 (sum)
  On and        reduce rule 15 (sum)
  On false      reduce rule 15 (sum)
  On [          reduce rule 15 (sum)
  On not        reduce rule 15 (sum)
  On +          reduce rule 15 (sum)
  On nil        reduce rule 15 (sum)
  On >=         reduce rule 15 (sum)
  On NUM        reduce rule 15 (sum)
  On or         reduce rule 15 (sum)
  On -          reduce rule 15 (sum)
  On (          reduce rule 15 (sum)
  On <          reduce rule 15 (sum)
  On if         reduce rule 15 (sum)
  On ,          reduce rule 15 (sum)
  On ==         reduce rule 15 (sum)
  On :          reduce rule 15 (sum)
  On )          reduce rule 15 (sum)
  On STR        reduce rule 15 (sum)
  On ID         reduce rule 15 (sum)
  On *          shift to state 56
  On #[         reduce rule 15 (sum)
  On <=         reduce rule 15 (sum)
  On !=         reduce rule 15 (sum)
  On ->         reduce rule 15 (sum)
  On true       reduce rule 15 (sum)

State 12
  object     → map •

  On /          reduce rule 30 (object)
  On {          reduce rule 30 (object)
  On NL         reduce rule 30 (object)
  On in         reduce rule 30 (object)
  On cond       reduce rule 30 (object)
  On >          reduce rule 30 (object)
  On do         reduce rule 30 (object)
  On and        reduce rule 30 (object)
  On false      reduce rule 30 (object)
  On [          reduce rule 30 (object)
  On not        reduce rule 30 (object)
  On +          reduce rule 30 (object)
  On nil        reduce rule 30 (object)
  On >=         reduce rule 30 (object)
  On NUM        reduce rule 30 (object)
  On or         reduce rule 30 (object)
  On -          reduce rule 30 (object)
  On (          reduce rule 30 (object)
  On <          reduce rule 30 (object)
  On if         reduce rule 30 (object)
  On ,          reduce rule 30 (object)
  On ==         reduce rule 30 (object)
  On :          reduce rule 30 (object)
  On )          reduce rule 30 (object)
  On STR        reduce rule 30 (object)
  On ID         reduce rule 30 (object)
  On *          reduce rule 30 (object)
  On #[         reduce rule 30 (object)
  On <=         reduce rule 30 (object)
  On !=         reduce rule 30 (object)
  On ->         reduce rule 30 (object)
  On true       reduce rule 30 (object)

State 13
  stmt       → let_stmt •

  On NL         reduce rule 2 (stmt)

State 14
  literal    → "false" •

  On /          reduce rule 19 (literal)
  On {          reduce rule 19 (literal)
  On NL         reduce rule 19 (literal)
  On in         reduce rule 19 (literal)
  On cond       reduce rule 19 (literal)
  On >          reduce rule 19 (literal)
  On do         reduce rule 19 (literal)
  On and        reduce rule 19 (literal)
  On false      reduce rule 19 (literal)
  On [          reduce rule 19 (literal)
  On not        reduce rule 19 (literal)
  On +          reduce rule 19 (literal)
  On nil        reduce rule 19 (literal)
  On >=         reduce rule 19 (literal)
  On NUM        reduce rule 19 (literal)
  On or         reduce rule 19 (literal)
  On -          reduce rule 19 (literal)
  On (          reduce rule 19 (literal)
  On <          reduce rule 19 (literal)
  On if         reduce rule 19 (literal)
  On ,          reduce rule 19 (literal)
  On ==         reduce rule 19 (literal)
  On :          reduce rule 19 (literal)
  On )          reduce rule 19 (literal)
  On STR        reduce rule 19 (literal)
  On ID         reduce rule 19 (literal)
  On *          reduce rule 19 (literal)
  On #[         reduce rule 19 (literal)
  On <=         reduce rule 19 (literal)
  On !=         reduce rule 19 (literal)
  On ->         reduce rule 19 (literal)
  On true       reduce rule 19 (literal)

State 15
  logic      → equals •

  On (          reduce rule 11 (logic)
  On {          reduce rule 11 (logic)
  On NL         reduce rule 11 (logic)
  On if         reduce rule 11 (logic)
  On ,          reduce rule 11 (logic)
  On cond       reduce rule 11 (logic)
  On :          reduce rule 11 (logic)
  On do         reduce rule 11 (logic)
  On )          reduce rule 11 (logic)
  On STR        reduce rule 11 (logic)
  On and        reduce rule 11 (logic)
  On false      reduce rule 11 (logic)
  On ID         reduce rule 11 (logic)
  On [          reduce rule 11 (logic)
  On #[         reduce rule 11 (logic)
  On not        reduce rule 11 (logic)
  On nil        reduce rule 11 (logic)
  On NUM        reduce rule 11 (logic)
  On ->         reduce rule 11 (logic)
  On true       reduce rule 11 (logic)
  On or         reduce rule 11 (logic)

State 16
  list       → "[" • items "]"
  items      → • items item
  items      → ε •

  On ]          reduce rule 34 (items)
  On (          reduce rule 34 (items)
  On {          reduce rule 34 (items)
  On if         reduce rule 34 (items)
  On cond       reduce rule 34 (items)
  On :          reduce rule 34 (items)
  On do         reduce rule 34 (items)
  On STR        reduce rule 34 (items)
  On false      reduce rule 34 (items)
  On ID         reduce rule 34 (items)
  On [          reduce rule 34 (items)
  On #[         reduce rule 34 (items)
  On not        reduce rule 34 (items)
  On nil        reduce rule 34 (items)
  On NUM        reduce rule 34 (items)
  On items      shift to state 57
  On true       reduce rule 34 (items)

State 17
  def_stmt   → "def" • "(" id_list ")" arg

  On (          shift to state 58

State 18
  unary      → "not" • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 61
  On ID         shift to state 62
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 19
  stmt       → call •
  call       → call • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On NL         reduce rule 2 (stmt)
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 63
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 20
  block      → if_block •

  On /          reduce rule 23 (block)
  On {          reduce rule 23 (block)
  On NL         reduce rule 23 (block)
  On in         reduce rule 23 (block)
  On cond       reduce rule 23 (block)
  On >          reduce rule 23 (block)
  On do         reduce rule 23 (block)
  On and        reduce rule 23 (block)
  On false      reduce rule 23 (block)
  On [          reduce rule 23 (block)
  On not        reduce rule 23 (block)
  On +          reduce rule 23 (block)
  On nil        reduce rule 23 (block)
  On >=         reduce rule 23 (block)
  On NUM        reduce rule 23 (block)
  On or         reduce rule 23 (block)
  On -          reduce rule 23 (block)
  On (          reduce rule 23 (block)
  On <          reduce rule 23 (block)
  On if         reduce rule 23 (block)
  On ,          reduce rule 23 (block)
  On ==         reduce rule 23 (block)
  On :          reduce rule 23 (block)
  On )          reduce rule 23 (block)
  On STR        reduce rule 23 (block)
  On ID         reduce rule 23 (block)
  On *          reduce rule 23 (block)
  On #[         reduce rule 23 (block)
  On <=         reduce rule 23 (block)
  On !=         reduce rule 23 (block)
  On ->         reduce rule 23 (block)
  On true       reduce rule 23 (block)

State 21
  let_stmt   → "let" • assigns
  assigns    → • assigns "," assign
  assigns    → • assign
  assign     → • ID "=" call

  On assign     shift to state 64
  On ID         shift to state 65
  On assigns    shift to state 66

State 22
  literal    → "nil" •

  On /          reduce rule 19 (literal)
  On {          reduce rule 19 (literal)
  On NL         reduce rule 19 (literal)
  On in         reduce rule 19 (literal)
  On cond       reduce rule 19 (literal)
  On >          reduce rule 19 (literal)
  On do         reduce rule 19 (literal)
  On and        reduce rule 19 (literal)
  On false      reduce rule 19 (literal)
  On [          reduce rule 19 (literal)
  On not        reduce rule 19 (literal)
  On +          reduce rule 19 (literal)
  On nil        reduce rule 19 (literal)
  On >=         reduce rule 19 (literal)
  On NUM        reduce rule 19 (literal)
  On or         reduce rule 19 (literal)
  On -          reduce rule 19 (literal)
  On (          reduce rule 19 (literal)
  On <          reduce rule 19 (literal)
  On if         reduce rule 19 (literal)
  On ,          reduce rule 19 (literal)
  On ==         reduce rule 19 (literal)
  On :          reduce rule 19 (literal)
  On )          reduce rule 19 (literal)
  On STR        reduce rule 19 (literal)
  On ID         reduce rule 19 (literal)
  On *          reduce rule 19 (literal)
  On #[         reduce rule 19 (literal)
  On <=         reduce rule 19 (literal)
  On !=         reduce rule 19 (literal)
  On ->         reduce rule 19 (literal)
  On true       reduce rule 19 (literal)

State 23
  primary    → access •
  access     → access • "." ID

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On .          shift to state 67
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 24
  primary    → NUM •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 25
  product    → unary •

  On /          reduce rule 16 (product)
  On {          reduce rule 16 (product)
  On NL         reduce rule 16 (product)
  On in         reduce rule 16 (product)
  On cond       reduce rule 16 (product)
  On >          reduce rule 16 (product)
  On do         reduce rule 16 (product)
  On and        reduce rule 16 (product)
  On false      reduce rule 16 (product)
  On [          reduce rule 16 (product)
  On not        reduce rule 16 (product)
  On +          reduce rule 16 (product)
  On nil        reduce rule 16 (product)
  On >=         reduce rule 16 (product)
  On NUM        reduce rule 16 (product)
  On or         reduce rule 16 (product)
  On -          reduce rule 16 (product)
  On (          reduce rule 16 (product)
  On <          reduce rule 16 (product)
  On if         reduce rule 16 (product)
  On ,          reduce rule 16 (product)
  On ==         reduce rule 16 (product)
  On :          reduce rule 16 (product)
  On )          reduce rule 16 (product)
  On STR        reduce rule 16 (product)
  On ID         reduce rule 16 (product)
  On *          reduce rule 16 (product)
  On #[         reduce rule 16 (product)
  On <=         reduce rule 16 (product)
  On !=         reduce rule 16 (product)
  On ->         reduce rule 16 (product)
  On true       reduce rule 16 (product)

State 26
  equals     → compare • "==" compare
  equals     → compare • "!=" compare
  equals     → compare •

  On (          reduce rule 12 (equals)
  On {          reduce rule 12 (equals)
  On NL         reduce rule 12 (equals)
  On if         reduce rule 12 (equals)
  On ,          reduce rule 12 (equals)
  On cond       reduce rule 12 (equals)
  On ==         shift to state 68
  On :          reduce rule 12 (equals)
  On do         reduce rule 12 (equals)
  On )          reduce rule 12 (equals)
  On STR        reduce rule 12 (equals)
  On and        reduce rule 12 (equals)
  On false      reduce rule 12 (equals)
  On ID         reduce rule 12 (equals)
  On [          reduce rule 12 (equals)
  On #[         reduce rule 12 (equals)
  On not        reduce rule 12 (equals)
  On nil        reduce rule 12 (equals)
  On !=         shift to state 69
  On NUM        reduce rule 12 (equals)
  On ->         reduce rule 12 (equals)
  On true       reduce rule 12 (equals)
  On or         reduce rule 12 (equals)

State 27
  primary    → object •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 28
  lambda     → "(" • ")" "->" logic
  group      → "(" • call ")"
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On call       shift to state 70
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On )          shift to state 71
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 29
  call       → arg •

  On (          reduce rule 8 (call)
  On {          reduce rule 8 (call)
  On NL         reduce rule 8 (call)
  On if         reduce rule 8 (call)
  On ,          reduce rule 8 (call)
  On cond       reduce rule 8 (call)
  On :          reduce rule 8 (call)
  On do         reduce rule 8 (call)
  On )          reduce rule 8 (call)
  On STR        reduce rule 8 (call)
  On false      reduce rule 8 (call)
  On ID         reduce rule 8 (call)
  On [          reduce rule 8 (call)
  On #[         reduce rule 8 (call)
  On not        reduce rule 8 (call)
  On nil        reduce rule 8 (call)
  On NUM        reduce rule 8 (call)
  On true       reduce rule 8 (call)

State 30
  if_block   → "if" • arg do_else
  if_block   → "if" • arg do_block nothing
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 72
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 31
  symbol     → ":" • ID

  On ID         shift to state 73

State 32
  lambda     → group • "->" logic
  primary    → group •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         shift to state 74
  On true       reduce rule 18 (primary)

State 33
  primary    → STR •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 34
  unary      → primary •

  On /          reduce rule 17 (unary)
  On {          reduce rule 17 (unary)
  On NL         reduce rule 17 (unary)
  On in         reduce rule 17 (unary)
  On cond       reduce rule 17 (unary)
  On >          reduce rule 17 (unary)
  On do         reduce rule 17 (unary)
  On and        reduce rule 17 (unary)
  On false      reduce rule 17 (unary)
  On [          reduce rule 17 (unary)
  On not        reduce rule 17 (unary)
  On +          reduce rule 17 (unary)
  On nil        reduce rule 17 (unary)
  On >=         reduce rule 17 (unary)
  On NUM        reduce rule 17 (unary)
  On or         reduce rule 17 (unary)
  On -          reduce rule 17 (unary)
  On (          reduce rule 17 (unary)
  On <          reduce rule 17 (unary)
  On if         reduce rule 17 (unary)
  On ,          reduce rule 17 (unary)
  On ==         reduce rule 17 (unary)
  On :          reduce rule 17 (unary)
  On )          reduce rule 17 (unary)
  On STR        reduce rule 17 (unary)
  On ID         reduce rule 17 (unary)
  On *          reduce rule 17 (unary)
  On #[         reduce rule 17 (unary)
  On <=         reduce rule 17 (unary)
  On !=         reduce rule 17 (unary)
  On ->         reduce rule 17 (unary)
  On true       reduce rule 17 (unary)

State 35
  lambda     → ID • "->" logic
  primary    → ID •
  access     → ID • "." ID

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On .          shift to state 75
  On ->         shift to state 76
  On true       reduce rule 18 (primary)

State 36
  compare    → member • ">" member
  compare    → member • ">=" member
  compare    → member • "<" member
  compare    → member • "<=" member
  compare    → member •

  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On >          shift to state 78
  On do         reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On >=         shift to state 80
  On NUM        reduce rule 13 (compare)
  On or         reduce rule 13 (compare)
  On (          reduce rule 13 (compare)
  On <          shift to state 77
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On <=         shift to state 79
  On !=         reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)

State 37
  tuple      → "#[" • items "]"
  items      → • items item
  items      → ε •

  On ]          reduce rule 34 (items)
  On (          reduce rule 34 (items)
  On {          reduce rule 34 (items)
  On if         reduce rule 34 (items)
  On cond       reduce rule 34 (items)
  On :          reduce rule 34 (items)
  On do         reduce rule 34 (items)
  On STR        reduce rule 34 (items)
  On false      reduce rule 34 (items)
  On ID         reduce rule 34 (items)
  On [          reduce rule 34 (items)
  On #[         reduce rule 34 (items)
  On not        reduce rule 34 (items)
  On nil        reduce rule 34 (items)
  On NUM        reduce rule 34 (items)
  On items      shift to state 81
  On true       reduce rule 34 (items)

State 38
  object     → list •

  On /          reduce rule 30 (object)
  On {          reduce rule 30 (object)
  On NL         reduce rule 30 (object)
  On in         reduce rule 30 (object)
  On cond       reduce rule 30 (object)
  On >          reduce rule 30 (object)
  On do         reduce rule 30 (object)
  On and        reduce rule 30 (object)
  On false      reduce rule 30 (object)
  On [          reduce rule 30 (object)
  On not        reduce rule 30 (object)
  On +          reduce rule 30 (object)
  On nil        reduce rule 30 (object)
  On >=         reduce rule 30 (object)
  On NUM        reduce rule 30 (object)
  On or         reduce rule 30 (object)
  On -          reduce rule 30 (object)
  On (          reduce rule 30 (object)
  On <          reduce rule 30 (object)
  On if         reduce rule 30 (object)
  On ,          reduce rule 30 (object)
  On ==         reduce rule 30 (object)
  On :          reduce rule 30 (object)
  On )          reduce rule 30 (object)
  On STR        reduce rule 30 (object)
  On ID         reduce rule 30 (object)
  On *          reduce rule 30 (object)
  On #[         reduce rule 30 (object)
  On <=         reduce rule 30 (object)
  On !=         reduce rule 30 (object)
  On ->         reduce rule 30 (object)
  On true       reduce rule 30 (object)

State 39
  program    → stmts $ •

State 40
  arg        → lambda •

  On (          reduce rule 9 (arg)
  On {          reduce rule 9 (arg)
  On NL         reduce rule 9 (arg)
  On if         reduce rule 9 (arg)
  On ,          reduce rule 9 (arg)
  On cond       reduce rule 9 (arg)
  On :          reduce rule 9 (arg)
  On do         reduce rule 9 (arg)
  On )          reduce rule 9 (arg)
  On STR        reduce rule 9 (arg)
  On false      reduce rule 9 (arg)
  On ID         reduce rule 9 (arg)
  On [          reduce rule 9 (arg)
  On #[         reduce rule 9 (arg)
  On not        reduce rule 9 (arg)
  On nil        reduce rule 9 (arg)
  On NUM        reduce rule 9 (arg)
  On true       reduce rule 9 (arg)

State 41
  block      → cond_block •

  On /          reduce rule 23 (block)
  On {          reduce rule 23 (block)
  On NL         reduce rule 23 (block)
  On in         reduce rule 23 (block)
  On cond       reduce rule 23 (block)
  On >          reduce rule 23 (block)
  On do         reduce rule 23 (block)
  On and        reduce rule 23 (block)
  On false      reduce rule 23 (block)
  On [          reduce rule 23 (block)
  On not        reduce rule 23 (block)
  On +          reduce rule 23 (block)
  On nil        reduce rule 23 (block)
  On >=         reduce rule 23 (block)
  On NUM        reduce rule 23 (block)
  On or         reduce rule 23 (block)
  On -          reduce rule 23 (block)
  On (          reduce rule 23 (block)
  On <          reduce rule 23 (block)
  On if         reduce rule 23 (block)
  On ,          reduce rule 23 (block)
  On ==         reduce rule 23 (block)
  On :          reduce rule 23 (block)
  On )          reduce rule 23 (block)
  On STR        reduce rule 23 (block)
  On ID         reduce rule 23 (block)
  On *          reduce rule 23 (block)
  On #[         reduce rule 23 (block)
  On <=         reduce rule 23 (block)
  On !=         reduce rule 23 (block)
  On ->         reduce rule 23 (block)
  On true       reduce rule 23 (block)

State 42
  stmt       → def_stmt •

  On NL         reduce rule 2 (stmt)

State 43
  primary    → block •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 44
  object     → tuple •

  On /          reduce rule 30 (object)
  On {          reduce rule 30 (object)
  On NL         reduce rule 30 (object)
  On in         reduce rule 30 (object)
  On cond       reduce rule 30 (object)
  On >          reduce rule 30 (object)
  On do         reduce rule 30 (object)
  On and        reduce rule 30 (object)
  On false      reduce rule 30 (object)
  On [          reduce rule 30 (object)
  On not        reduce rule 30 (object)
  On +          reduce rule 30 (object)
  On nil        reduce rule 30 (object)
  On >=         reduce rule 30 (object)
  On NUM        reduce rule 30 (object)
  On or         reduce rule 30 (object)
  On -          reduce rule 30 (object)
  On (          reduce rule 30 (object)
  On <          reduce rule 30 (object)
  On if         reduce rule 30 (object)
  On ,          reduce rule 30 (object)
  On ==         reduce rule 30 (object)
  On :          reduce rule 30 (object)
  On )          reduce rule 30 (object)
  On STR        reduce rule 30 (object)
  On ID         reduce rule 30 (object)
  On *          reduce rule 30 (object)
  On #[         reduce rule 30 (object)
  On <=         reduce rule 30 (object)
  On !=         reduce rule 30 (object)
  On ->         reduce rule 30 (object)
  On true       reduce rule 30 (object)

State 45
  stmts      → stmts stmt • NL

  On NL         shift to state 82

State 46
  literal    → "true" •

  On /          reduce rule 19 (literal)
  On {          reduce rule 19 (literal)
  On NL         reduce rule 19 (literal)
  On in         reduce rule 19 (literal)
  On cond       reduce rule 19 (literal)
  On >          reduce rule 19 (literal)
  On do         reduce rule 19 (literal)
  On and        reduce rule 19 (literal)
  On false      reduce rule 19 (literal)
  On [          reduce rule 19 (literal)
  On not        reduce rule 19 (literal)
  On +          reduce rule 19 (literal)
  On nil        reduce rule 19 (literal)
  On >=         reduce rule 19 (literal)
  On NUM        reduce rule 19 (literal)
  On or         reduce rule 19 (literal)
  On -          reduce rule 19 (literal)
  On (          reduce rule 19 (literal)
  On <          reduce rule 19 (literal)
  On if         reduce rule 19 (literal)
  On ,          reduce rule 19 (literal)
  On ==         reduce rule 19 (literal)
  On :          reduce rule 19 (literal)
  On )          reduce rule 19 (literal)
  On STR        reduce rule 19 (literal)
  On ID         reduce rule 19 (literal)
  On *          reduce rule 19 (literal)
  On #[         reduce rule 19 (literal)
  On <=         reduce rule 19 (literal)
  On !=         reduce rule 19 (literal)
  On ->         reduce rule 19 (literal)
  On true       reduce rule 19 (literal)

State 47
  sum        → sum "-" • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 83
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 48
  member     → sum "in" • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 84
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 49
  sum        → sum "+" • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 85
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 50
  map        → "{" entries • "}"
  entries    → entries • entry
  entry      → • ID ":" arg opt_comma

  On entry      shift to state 86
  On }          shift to state 87
  On ID         shift to state 88

State 51
  logic      → logic "and" • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 89
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 52
  logic      → logic "or" • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 90
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 53
  cond_block → "cond" "do" • clauses "end"
  clauses    → • clauses clause
  clauses    → • NL
  clauses    → ε •

  On clauses    shift to state 91
  On (          reduce rule 28 (clauses)
  On {          reduce rule 28 (clauses)
  On NL         shift to state 92
  On if         reduce rule 28 (clauses)
  On cond       reduce rule 28 (clauses)
  On :          reduce rule 28 (clauses)
  On do         reduce rule 28 (clauses)
  On STR        reduce rule 28 (clauses)
  On false      reduce rule 28 (clauses)
  On ID         reduce rule 28 (clauses)
  On [          reduce rule 28 (clauses)
  On #[         reduce rule 28 (clauses)
  On not        reduce rule 28 (clauses)
  On end        reduce rule 28 (clauses)
  On nil        reduce rule 28 (clauses)
  On NUM        reduce rule 28 (clauses)
  On true       reduce rule 28 (clauses)

State 54
  do_block   → "do" stmts • "end"
  stmts      → stmts • stmt NL
  stmt       → • let_stmt
  stmt       → • def_stmt
  stmt       → • call
  let_stmt   → • "let" assigns
  def_stmt   → • "def" "(" id_list ")" arg
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On literal    shift to state 3
  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On let_stmt   shift to state 13
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On def        shift to state 17
  On not        shift to state 18
  On end        shift to state 93
  On call       shift to state 19
  On if_block   shift to state 20
  On let        shift to state 21
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On def_stmt   shift to state 42
  On block      shift to state 43
  On tuple      shift to state 44
  On stmt       shift to state 45
  On true       shift to state 46

State 55
  product    → product "/" • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 94
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 56
  product    → product "*" • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 95
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 57
  list       → "[" items • "]"
  items      → items • item
  item       → • arg opt_comma
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On ]          shift to state 96
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 97
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On item       shift to state 98
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 58
  def_stmt   → "def" "(" • id_list ")" arg
  id_list    → • id_list ID
  id_list    → • ID

  On id_list    shift to state 99
  On ID         shift to state 100

State 59
  group      → "(" • call ")"
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On call       shift to state 70
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 60
  primary    → group •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 61
  unary      → "not" primary •

  On /          reduce rule 17 (unary)
  On {          reduce rule 17 (unary)
  On NL         reduce rule 17 (unary)
  On in         reduce rule 17 (unary)
  On cond       reduce rule 17 (unary)
  On >          reduce rule 17 (unary)
  On do         reduce rule 17 (unary)
  On and        reduce rule 17 (unary)
  On false      reduce rule 17 (unary)
  On [          reduce rule 17 (unary)
  On not        reduce rule 17 (unary)
  On +          reduce rule 17 (unary)
  On nil        reduce rule 17 (unary)
  On >=         reduce rule 17 (unary)
  On NUM        reduce rule 17 (unary)
  On or         reduce rule 17 (unary)
  On -          reduce rule 17 (unary)
  On (          reduce rule 17 (unary)
  On <          reduce rule 17 (unary)
  On if         reduce rule 17 (unary)
  On ,          reduce rule 17 (unary)
  On ==         reduce rule 17 (unary)
  On :          reduce rule 17 (unary)
  On )          reduce rule 17 (unary)
  On STR        reduce rule 17 (unary)
  On ID         reduce rule 17 (unary)
  On *          reduce rule 17 (unary)
  On #[         reduce rule 17 (unary)
  On <=         reduce rule 17 (unary)
  On !=         reduce rule 17 (unary)
  On ->         reduce rule 17 (unary)
  On true       reduce rule 17 (unary)

State 62
  primary    → ID •
  access     → ID • "." ID

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On .          shift to state 75
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 63
  call       → call arg •

  On (          reduce rule 8 (call)
  On {          reduce rule 8 (call)
  On NL         reduce rule 8 (call)
  On if         reduce rule 8 (call)
  On ,          reduce rule 8 (call)
  On cond       reduce rule 8 (call)
  On :          reduce rule 8 (call)
  On do         reduce rule 8 (call)
  On )          reduce rule 8 (call)
  On STR        reduce rule 8 (call)
  On false      reduce rule 8 (call)
  On ID         reduce rule 8 (call)
  On [          reduce rule 8 (call)
  On #[         reduce rule 8 (call)
  On not        reduce rule 8 (call)
  On nil        reduce rule 8 (call)
  On NUM        reduce rule 8 (call)
  On true       reduce rule 8 (call)

State 64
  assigns    → assign •

  On NL         reduce rule 4 (assigns)
  On ,          reduce rule 4 (assigns)

State 65
  assign     → ID • "=" call

  On =          shift to state 101

State 66
  let_stmt   → "let" assigns •
  assigns    → assigns • "," assign

  On NL         reduce rule 3 (let_stmt)
  On ,          shift to state 102

State 67
  access     → access "." • ID

  On ID         shift to state 103

State 68
  equals     → compare "==" • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 104
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 69
  equals     → compare "!=" • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 105
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 70
  group      → "(" call • ")"
  call       → call • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 63
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On )          shift to state 106
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 71
  lambda     → "(" ")" • "->" logic

  On ->         shift to state 107

State 72
  if_block   → "if" arg • do_else
  if_block   → "if" arg • do_block nothing
  do_else    → • "do" stmts "else" stmts "end"
  do_block   → • "do" stmts "end"

  On do_block   shift to state 108
  On do_else    shift to state 109
  On do         shift to state 110

State 73
  symbol     → ":" ID •

  On /          reduce rule 20 (symbol)
  On {          reduce rule 20 (symbol)
  On NL         reduce rule 20 (symbol)
  On in         reduce rule 20 (symbol)
  On cond       reduce rule 20 (symbol)
  On >          reduce rule 20 (symbol)
  On do         reduce rule 20 (symbol)
  On and        reduce rule 20 (symbol)
  On false      reduce rule 20 (symbol)
  On [          reduce rule 20 (symbol)
  On not        reduce rule 20 (symbol)
  On +          reduce rule 20 (symbol)
  On nil        reduce rule 20 (symbol)
  On >=         reduce rule 20 (symbol)
  On NUM        reduce rule 20 (symbol)
  On or         reduce rule 20 (symbol)
  On -          reduce rule 20 (symbol)
  On (          reduce rule 20 (symbol)
  On <          reduce rule 20 (symbol)
  On if         reduce rule 20 (symbol)
  On ,          reduce rule 20 (symbol)
  On ==         reduce rule 20 (symbol)
  On :          reduce rule 20 (symbol)
  On )          reduce rule 20 (symbol)
  On STR        reduce rule 20 (symbol)
  On ID         reduce rule 20 (symbol)
  On *          reduce rule 20 (symbol)
  On #[         reduce rule 20 (symbol)
  On <=         reduce rule 20 (symbol)
  On !=         reduce rule 20 (symbol)
  On ->         reduce rule 20 (symbol)
  On true       reduce rule 20 (symbol)

State 74
  lambda     → group "->" • logic
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 111
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 75
  access     → ID "." • ID

  On ID         shift to state 112

State 76
  lambda     → ID "->" • logic
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 113
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 77
  compare    → member "<" • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 114
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 78
  compare    → member ">" • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 115
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 79
  compare    → member "<=" • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 116
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 80
  compare    → member ">=" • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 117
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 81
  tuple      → "#[" items • "]"
  items      → items • item
  item       → • arg opt_comma
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On ]          shift to state 118
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 97
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On item       shift to state 98
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 82
  stmts      → stmts stmt NL •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 83
  sum        → sum "-" product •
  product    → product • "*" unary
  product    → product • "/" unary

  On /          shift to state 55
  On {          reduce rule 15 (sum)
  On NL         reduce rule 15 (sum)
  On in         reduce rule 15 (sum)
  On cond       reduce rule 15 (sum)
  On >          reduce rule 15 (sum)
  On do         reduce rule 15 (sum)
  On and        reduce rule 15 (sum)
  On false      reduce rule 15 (sum)
  On [          reduce rule 15 (sum)
  On not        reduce rule 15 (sum)
  On +          reduce rule 15 (sum)
  On nil        reduce rule 15 (sum)
  On >=         reduce rule 15 (sum)
  On NUM        reduce rule 15 (sum)
  On or         reduce rule 15 (sum)
  On -          reduce rule 15 (sum)
  On (          reduce rule 15 (sum)
  On <          reduce rule 15 (sum)
  On if         reduce rule 15 (sum)
  On ,          reduce rule 15 (sum)
  On ==         reduce rule 15 (sum)
  On :          reduce rule 15 (sum)
  On )          reduce rule 15 (sum)
  On STR        reduce rule 15 (sum)
  On ID         reduce rule 15 (sum)
  On *          shift to state 56
  On #[         reduce rule 15 (sum)
  On <=         reduce rule 15 (sum)
  On !=         reduce rule 15 (sum)
  On ->         reduce rule 15 (sum)
  On true       reduce rule 15 (sum)

State 84
  member     → sum "in" sum •
  sum        → sum • "+" product
  sum        → sum • "-" product

  On {          reduce rule 14 (member)
  On NL         reduce rule 14 (member)
  On cond       reduce rule 14 (member)
  On >          reduce rule 14 (member)
  On do         reduce rule 14 (member)
  On and        reduce rule 14 (member)
  On false      reduce rule 14 (member)
  On [          reduce rule 14 (member)
  On not        reduce rule 14 (member)
  On +          shift to state 49
  On nil        reduce rule 14 (member)
  On >=         reduce rule 14 (member)
  On NUM        reduce rule 14 (member)
  On or         reduce rule 14 (member)
  On -          shift to state 47
  On (          reduce rule 14 (member)
  On <          reduce rule 14 (member)
  On if         reduce rule 14 (member)
  On ,          reduce rule 14 (member)
  On ==         reduce rule 14 (member)
  On :          reduce rule 14 (member)
  On )          reduce rule 14 (member)
  On STR        reduce rule 14 (member)
  On ID         reduce rule 14 (member)
  On #[         reduce rule 14 (member)
  On <=         reduce rule 14 (member)
  On !=         reduce rule 14 (member)
  On ->         reduce rule 14 (member)
  On true       reduce rule 14 (member)

State 85
  sum        → sum "+" product •
  product    → product • "*" unary
  product    → product • "/" unary

  On /          shift to state 55
  On {          reduce rule 15 (sum)
  On NL         reduce rule 15 (sum)
  On in         reduce rule 15 (sum)
  On cond       reduce rule 15 (sum)
  On >          reduce rule 15 (sum)
  On do         reduce rule 15 (sum)
  On and        reduce rule 15 (sum)
  On false      reduce rule 15 (sum)
  On [          reduce rule 15 (sum)
  On not        reduce rule 15 (sum)
  On +          reduce rule 15 (sum)
  On nil        reduce rule 15 (sum)
  On >=         reduce rule 15 (sum)
  On NUM        reduce rule 15 (sum)
  On or         reduce rule 15 (sum)
  On -          reduce rule 15 (sum)
  On (          reduce rule 15 (sum)
  On <          reduce rule 15 (sum)
  On if         reduce rule 15 (sum)
  On ,          reduce rule 15 (sum)
  On ==         reduce rule 15 (sum)
  On :          reduce rule 15 (sum)
  On )          reduce rule 15 (sum)
  On STR        reduce rule 15 (sum)
  On ID         reduce rule 15 (sum)
  On *          shift to state 56
  On #[         reduce rule 15 (sum)
  On <=         reduce rule 15 (sum)
  On !=         reduce rule 15 (sum)
  On ->         reduce rule 15 (sum)
  On true       reduce rule 15 (sum)

State 86
  entries    → entries entry •

  On }          reduce rule 36 (entries)
  On ID         reduce rule 36 (entries)

State 87
  map        → "{" entries "}" •

  On /          reduce rule 33 (map)
  On {          reduce rule 33 (map)
  On NL         reduce rule 33 (map)
  On in         reduce rule 33 (map)
  On cond       reduce rule 33 (map)
  On >          reduce rule 33 (map)
  On do         reduce rule 33 (map)
  On and        reduce rule 33 (map)
  On false      reduce rule 33 (map)
  On [          reduce rule 33 (map)
  On not        reduce rule 33 (map)
  On +          reduce rule 33 (map)
  On nil        reduce rule 33 (map)
  On >=         reduce rule 33 (map)
  On NUM        reduce rule 33 (map)
  On or         reduce rule 33 (map)
  On -          reduce rule 33 (map)
  On (          reduce rule 33 (map)
  On <          reduce rule 33 (map)
  On if         reduce rule 33 (map)
  On ,          reduce rule 33 (map)
  On ==         reduce rule 33 (map)
  On :          reduce rule 33 (map)
  On )          reduce rule 33 (map)
  On STR        reduce rule 33 (map)
  On ID         reduce rule 33 (map)
  On *          reduce rule 33 (map)
  On #[         reduce rule 33 (map)
  On <=         reduce rule 33 (map)
  On !=         reduce rule 33 (map)
  On ->         reduce rule 33 (map)
  On true       reduce rule 33 (map)

State 88
  entry      → ID • ":" arg opt_comma

  On :          shift to state 119

State 89
  logic      → logic "and" equals •

  On (          reduce rule 11 (logic)
  On {          reduce rule 11 (logic)
  On NL         reduce rule 11 (logic)
  On if         reduce rule 11 (logic)
  On ,          reduce rule 11 (logic)
  On cond       reduce rule 11 (logic)
  On :          reduce rule 11 (logic)
  On do         reduce rule 11 (logic)
  On )          reduce rule 11 (logic)
  On STR        reduce rule 11 (logic)
  On and        reduce rule 11 (logic)
  On false      reduce rule 11 (logic)
  On ID         reduce rule 11 (logic)
  On [          reduce rule 11 (logic)
  On #[         reduce rule 11 (logic)
  On not        reduce rule 11 (logic)
  On nil        reduce rule 11 (logic)
  On NUM        reduce rule 11 (logic)
  On ->         reduce rule 11 (logic)
  On true       reduce rule 11 (logic)
  On or         reduce rule 11 (logic)

State 90
  logic      → logic "or" equals •

  On (          reduce rule 11 (logic)
  On {          reduce rule 11 (logic)
  On NL         reduce rule 11 (logic)
  On if         reduce rule 11 (logic)
  On ,          reduce rule 11 (logic)
  On cond       reduce rule 11 (logic)
  On :          reduce rule 11 (logic)
  On do         reduce rule 11 (logic)
  On )          reduce rule 11 (logic)
  On STR        reduce rule 11 (logic)
  On and        reduce rule 11 (logic)
  On false      reduce rule 11 (logic)
  On ID         reduce rule 11 (logic)
  On [          reduce rule 11 (logic)
  On #[         reduce rule 11 (logic)
  On not        reduce rule 11 (logic)
  On nil        reduce rule 11 (logic)
  On NUM        reduce rule 11 (logic)
  On ->         reduce rule 11 (logic)
  On true       reduce rule 11 (logic)
  On or         reduce rule 11 (logic)

State 91
  cond_block → "cond" "do" clauses • "end"
  clauses    → clauses • clause
  clause     → • logic "->" call NL
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 120
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On clause     shift to state 121
  On not        shift to state 18
  On end        shift to state 122
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 92
  clauses    → NL •

  On (          reduce rule 28 (clauses)
  On {          reduce rule 28 (clauses)
  On if         reduce rule 28 (clauses)
  On cond       reduce rule 28 (clauses)
  On :          reduce rule 28 (clauses)
  On do         reduce rule 28 (clauses)
  On STR        reduce rule 28 (clauses)
  On false      reduce rule 28 (clauses)
  On ID         reduce rule 28 (clauses)
  On [          reduce rule 28 (clauses)
  On #[         reduce rule 28 (clauses)
  On not        reduce rule 28 (clauses)
  On end        reduce rule 28 (clauses)
  On nil        reduce rule 28 (clauses)
  On NUM        reduce rule 28 (clauses)
  On true       reduce rule 28 (clauses)

State 93
  do_block   → "do" stmts "end" •

  On /          reduce rule 24 (do_block)
  On {          reduce rule 24 (do_block)
  On NL         reduce rule 24 (do_block)
  On in         reduce rule 24 (do_block)
  On cond       reduce rule 24 (do_block)
  On >          reduce rule 24 (do_block)
  On do         reduce rule 24 (do_block)
  On and        reduce rule 24 (do_block)
  On false      reduce rule 24 (do_block)
  On [          reduce rule 24 (do_block)
  On not        reduce rule 24 (do_block)
  On +          reduce rule 24 (do_block)
  On nil        reduce rule 24 (do_block)
  On >=         reduce rule 24 (do_block)
  On NUM        reduce rule 24 (do_block)
  On or         reduce rule 24 (do_block)
  On -          reduce rule 24 (do_block)
  On (          reduce rule 24 (do_block)
  On <          reduce rule 24 (do_block)
  On if         reduce rule 24 (do_block)
  On ,          reduce rule 24 (do_block)
  On ==         reduce rule 24 (do_block)
  On :          reduce rule 24 (do_block)
  On )          reduce rule 24 (do_block)
  On STR        reduce rule 24 (do_block)
  On ID         reduce rule 24 (do_block)
  On *          reduce rule 24 (do_block)
  On #[         reduce rule 24 (do_block)
  On <=         reduce rule 24 (do_block)
  On !=         reduce rule 24 (do_block)
  On ->         reduce rule 24 (do_block)
  On true       reduce rule 24 (do_block)

State 94
  product    → product "/" unary •

  On /          reduce rule 16 (product)
  On {          reduce rule 16 (product)
  On NL         reduce rule 16 (product)
  On in         reduce rule 16 (product)
  On cond       reduce rule 16 (product)
  On >          reduce rule 16 (product)
  On do         reduce rule 16 (product)
  On and        reduce rule 16 (product)
  On false      reduce rule 16 (product)
  On [          reduce rule 16 (product)
  On not        reduce rule 16 (product)
  On +          reduce rule 16 (product)
  On nil        reduce rule 16 (product)
  On >=         reduce rule 16 (product)
  On NUM        reduce rule 16 (product)
  On or         reduce rule 16 (product)
  On -          reduce rule 16 (product)
  On (          reduce rule 16 (product)
  On <          reduce rule 16 (product)
  On if         reduce rule 16 (product)
  On ,          reduce rule 16 (product)
  On ==         reduce rule 16 (product)
  On :          reduce rule 16 (product)
  On )          reduce rule 16 (product)
  On STR        reduce rule 16 (product)
  On ID         reduce rule 16 (product)
  On *          reduce rule 16 (product)
  On #[         reduce rule 16 (product)
  On <=         reduce rule 16 (product)
  On !=         reduce rule 16 (product)
  On ->         reduce rule 16 (product)
  On true       reduce rule 16 (product)

State 95
  product    → product "*" unary •

  On /          reduce rule 16 (product)
  On {          reduce rule 16 (product)
  On NL         reduce rule 16 (product)
  On in         reduce rule 16 (product)
  On cond       reduce rule 16 (product)
  On >          reduce rule 16 (product)
  On do         reduce rule 16 (product)
  On and        reduce rule 16 (product)
  On false      reduce rule 16 (product)
  On [          reduce rule 16 (product)
  On not        reduce rule 16 (product)
  On +          reduce rule 16 (product)
  On nil        reduce rule 16 (product)
  On >=         reduce rule 16 (product)
  On NUM        reduce rule 16 (product)
  On or         reduce rule 16 (product)
  On -          reduce rule 16 (product)
  On (          reduce rule 16 (product)
  On <          reduce rule 16 (product)
  On if         reduce rule 16 (product)
  On ,          reduce rule 16 (product)
  On ==         reduce rule 16 (product)
  On :          reduce rule 16 (product)
  On )          reduce rule 16 (product)
  On STR        reduce rule 16 (product)
  On ID         reduce rule 16 (product)
  On *          reduce rule 16 (product)
  On #[         reduce rule 16 (product)
  On <=         reduce rule 16 (product)
  On !=         reduce rule 16 (product)
  On ->         reduce rule 16 (product)
  On true       reduce rule 16 (product)

State 96
  list       → "[" items "]" •

  On /          reduce rule 31 (list)
  On {          reduce rule 31 (list)
  On NL         reduce rule 31 (list)
  On in         reduce rule 31 (list)
  On cond       reduce rule 31 (list)
  On >          reduce rule 31 (list)
  On do         reduce rule 31 (list)
  On and        reduce rule 31 (list)
  On false      reduce rule 31 (list)
  On [          reduce rule 31 (list)
  On not        reduce rule 31 (list)
  On +          reduce rule 31 (list)
  On nil        reduce rule 31 (list)
  On >=         reduce rule 31 (list)
  On NUM        reduce rule 31 (list)
  On or         reduce rule 31 (list)
  On -          reduce rule 31 (list)
  On (          reduce rule 31 (list)
  On <          reduce rule 31 (list)
  On if         reduce rule 31 (list)
  On ,          reduce rule 31 (list)
  On ==         reduce rule 31 (list)
  On :          reduce rule 31 (list)
  On )          reduce rule 31 (list)
  On STR        reduce rule 31 (list)
  On ID         reduce rule 31 (list)
  On *          reduce rule 31 (list)
  On #[         reduce rule 31 (list)
  On <=         reduce rule 31 (list)
  On !=         reduce rule 31 (list)
  On ->         reduce rule 31 (list)
  On true       reduce rule 31 (list)

State 97
  item       → arg • opt_comma
  opt_comma  → • ","
  opt_comma  → • NL
  opt_comma  → ε •

  On ]          reduce rule 38 (opt_comma)
  On (          reduce rule 38 (opt_comma)
  On {          reduce rule 38 (opt_comma)
  On NL         shift to state 123
  On if         reduce rule 38 (opt_comma)
  On ,          shift to state 124
  On cond       reduce rule 38 (opt_comma)
  On :          reduce rule 38 (opt_comma)
  On do         reduce rule 38 (opt_comma)
  On }          reduce rule 38 (opt_comma)
  On STR        reduce rule 38 (opt_comma)
  On false      reduce rule 38 (opt_comma)
  On ID         reduce rule 38 (opt_comma)
  On [          reduce rule 38 (opt_comma)
  On #[         reduce rule 38 (opt_comma)
  On not        reduce rule 38 (opt_comma)
  On nil        reduce rule 38 (opt_comma)
  On opt_comma  shift to state 125
  On NUM        reduce rule 38 (opt_comma)
  On true       reduce rule 38 (opt_comma)

State 98
  items      → items item •

  On ]          reduce rule 34 (items)
  On (          reduce rule 34 (items)
  On {          reduce rule 34 (items)
  On if         reduce rule 34 (items)
  On cond       reduce rule 34 (items)
  On :          reduce rule 34 (items)
  On do         reduce rule 34 (items)
  On STR        reduce rule 34 (items)
  On false      reduce rule 34 (items)
  On ID         reduce rule 34 (items)
  On [          reduce rule 34 (items)
  On #[         reduce rule 34 (items)
  On not        reduce rule 34 (items)
  On nil        reduce rule 34 (items)
  On NUM        reduce rule 34 (items)
  On true       reduce rule 34 (items)

State 99
  def_stmt   → "def" "(" id_list • ")" arg
  id_list    → id_list • ID

  On )          shift to state 126
  On ID         shift to state 127

State 100
  id_list    → ID •

  On )          reduce rule 7 (id_list)
  On ID         reduce rule 7 (id_list)

State 101
  assign     → ID "=" • call
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On call       shift to state 128
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 102
  assigns    → assigns "," • assign
  assign     → • ID "=" call

  On assign     shift to state 129
  On ID         shift to state 65

State 103
  access     → access "." ID •

  On /          reduce rule 21 (access)
  On {          reduce rule 21 (access)
  On NL         reduce rule 21 (access)
  On in         reduce rule 21 (access)
  On cond       reduce rule 21 (access)
  On >          reduce rule 21 (access)
  On do         reduce rule 21 (access)
  On and        reduce rule 21 (access)
  On false      reduce rule 21 (access)
  On [          reduce rule 21 (access)
  On not        reduce rule 21 (access)
  On +          reduce rule 21 (access)
  On nil        reduce rule 21 (access)
  On >=         reduce rule 21 (access)
  On NUM        reduce rule 21 (access)
  On or         reduce rule 21 (access)
  On -          reduce rule 21 (access)
  On (          reduce rule 21 (access)
  On <          reduce rule 21 (access)
  On if         reduce rule 21 (access)
  On ,          reduce rule 21 (access)
  On ==         reduce rule 21 (access)
  On :          reduce rule 21 (access)
  On )          reduce rule 21 (access)
  On STR        reduce rule 21 (access)
  On ID         reduce rule 21 (access)
  On *          reduce rule 21 (access)
  On #[         reduce rule 21 (access)
  On <=         reduce rule 21 (access)
  On !=         reduce rule 21 (access)
  On .          reduce rule 21 (access)
  On ->         reduce rule 21 (access)
  On true       reduce rule 21 (access)

State 104
  equals     → compare "==" compare •

  On (          reduce rule 12 (equals)
  On {          reduce rule 12 (equals)
  On NL         reduce rule 12 (equals)
  On if         reduce rule 12 (equals)
  On ,          reduce rule 12 (equals)
  On cond       reduce rule 12 (equals)
  On :          reduce rule 12 (equals)
  On do         reduce rule 12 (equals)
  On )          reduce rule 12 (equals)
  On STR        reduce rule 12 (equals)
  On and        reduce rule 12 (equals)
  On false      reduce rule 12 (equals)
  On ID         reduce rule 12 (equals)
  On [          reduce rule 12 (equals)
  On #[         reduce rule 12 (equals)
  On not        reduce rule 12 (equals)
  On nil        reduce rule 12 (equals)
  On NUM        reduce rule 12 (equals)
  On ->         reduce rule 12 (equals)
  On true       reduce rule 12 (equals)
  On or         reduce rule 12 (equals)

State 105
  equals     → compare "!=" compare •

  On (          reduce rule 12 (equals)
  On {          reduce rule 12 (equals)
  On NL         reduce rule 12 (equals)
  On if         reduce rule 12 (equals)
  On ,          reduce rule 12 (equals)
  On cond       reduce rule 12 (equals)
  On :          reduce rule 12 (equals)
  On do         reduce rule 12 (equals)
  On )          reduce rule 12 (equals)
  On STR        reduce rule 12 (equals)
  On and        reduce rule 12 (equals)
  On false      reduce rule 12 (equals)
  On ID         reduce rule 12 (equals)
  On [          reduce rule 12 (equals)
  On #[         reduce rule 12 (equals)
  On not        reduce rule 12 (equals)
  On nil        reduce rule 12 (equals)
  On NUM        reduce rule 12 (equals)
  On ->         reduce rule 12 (equals)
  On true       reduce rule 12 (equals)
  On or         reduce rule 12 (equals)

State 106
  group      → "(" call ")" •

  On /          reduce rule 22 (group)
  On {          reduce rule 22 (group)
  On NL         reduce rule 22 (group)
  On in         reduce rule 22 (group)
  On cond       reduce rule 22 (group)
  On >          reduce rule 22 (group)
  On do         reduce rule 22 (group)
  On and        reduce rule 22 (group)
  On false      reduce rule 22 (group)
  On [          reduce rule 22 (group)
  On not        reduce rule 22 (group)
  On +          reduce rule 22 (group)
  On nil        reduce rule 22 (group)
  On >=         reduce rule 22 (group)
  On NUM        reduce rule 22 (group)
  On or         reduce rule 22 (group)
  On -          reduce rule 22 (group)
  On (          reduce rule 22 (group)
  On <          reduce rule 22 (group)
  On if         reduce rule 22 (group)
  On ,          reduce rule 22 (group)
  On ==         reduce rule 22 (group)
  On :          reduce rule 22 (group)
  On )          reduce rule 22 (group)
  On STR        reduce rule 22 (group)
  On ID         reduce rule 22 (group)
  On *          reduce rule 22 (group)
  On #[         reduce rule 22 (group)
  On <=         reduce rule 22 (group)
  On !=         reduce rule 22 (group)
  On ->         reduce rule 22 (group)
  On true       reduce rule 22 (group)

State 107
  lambda     → "(" ")" "->" • logic
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 130
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 59
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 60
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 62
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 108
  if_block   → "if" arg do_block • nothing
  nothing    → ε •

  On /          reduce rule 39 (nothing)
  On {          reduce rule 39 (nothing)
  On NL         reduce rule 39 (nothing)
  On in         reduce rule 39 (nothing)
  On cond       reduce rule 39 (nothing)
  On >          reduce rule 39 (nothing)
  On do         reduce rule 39 (nothing)
  On and        reduce rule 39 (nothing)
  On false      reduce rule 39 (nothing)
  On [          reduce rule 39 (nothing)
  On not        reduce rule 39 (nothing)
  On +          reduce rule 39 (nothing)
  On nil        reduce rule 39 (nothing)
  On >=         reduce rule 39 (nothing)
  On NUM        reduce rule 39 (nothing)
  On or         reduce rule 39 (nothing)
  On -          reduce rule 39 (nothing)
  On (          reduce rule 39 (nothing)
  On <          reduce rule 39 (nothing)
  On if         reduce rule 39 (nothing)
  On ,          reduce rule 39 (nothing)
  On ==         reduce rule 39 (nothing)
  On :          reduce rule 39 (nothing)
  On nothing    shift to state 131
  On )          reduce rule 39 (nothing)
  On STR        reduce rule 39 (nothing)
  On ID         reduce rule 39 (nothing)
  On *          reduce rule 39 (nothing)
  On #[         reduce rule 39 (nothing)
  On <=         reduce rule 39 (nothing)
  On !=         reduce rule 39 (nothing)
  On ->         reduce rule 39 (nothing)
  On true       reduce rule 39 (nothing)

State 109
  if_block   → "if" arg do_else •

  On /          reduce rule 25 (if_block)
  On {          reduce rule 25 (if_block)
  On NL         reduce rule 25 (if_block)
  On in         reduce rule 25 (if_block)
  On cond       reduce rule 25 (if_block)
  On >          reduce rule 25 (if_block)
  On do         reduce rule 25 (if_block)
  On and        reduce rule 25 (if_block)
  On false      reduce rule 25 (if_block)
  On [          reduce rule 25 (if_block)
  On not        reduce rule 25 (if_block)
  On +          reduce rule 25 (if_block)
  On nil        reduce rule 25 (if_block)
  On >=         reduce rule 25 (if_block)
  On NUM        reduce rule 25 (if_block)
  On or         reduce rule 25 (if_block)
  On -          reduce rule 25 (if_block)
  On (          reduce rule 25 (if_block)
  On <          reduce rule 25 (if_block)
  On if         reduce rule 25 (if_block)
  On ,          reduce rule 25 (if_block)
  On ==         reduce rule 25 (if_block)
  On :          reduce rule 25 (if_block)
  On )          reduce rule 25 (if_block)
  On STR        reduce rule 25 (if_block)
  On ID         reduce rule 25 (if_block)
  On *          reduce rule 25 (if_block)
  On #[         reduce rule 25 (if_block)
  On <=         reduce rule 25 (if_block)
  On !=         reduce rule 25 (if_block)
  On ->         reduce rule 25 (if_block)
  On true       reduce rule 25 (if_block)

State 110
  do_else    → "do" • stmts "else" stmts "end"
  do_block   → "do" • stmts "end"
  stmts      → • stmts stmt NL
  stmts      → • NL
  stmts      → ε •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On NL         shift to state 1
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On stmts      shift to state 132
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 111
  lambda     → group "->" logic •
  logic      → logic • "and" equals
  logic      → logic • "or" equals

  On (          reduce rule 10 (lambda)
  On {          reduce rule 10 (lambda)
  On NL         reduce rule 10 (lambda)
  On if         reduce rule 10 (lambda)
  On ,          reduce rule 10 (lambda)
  On cond       reduce rule 10 (lambda)
  On :          reduce rule 10 (lambda)
  On do         reduce rule 10 (lambda)
  On )          reduce rule 10 (lambda)
  On STR        reduce rule 10 (lambda)
  On and        shift to state 51
  On false      reduce rule 10 (lambda)
  On ID         reduce rule 10 (lambda)
  On [          reduce rule 10 (lambda)
  On #[         reduce rule 10 (lambda)
  On not        reduce rule 10 (lambda)
  On nil        reduce rule 10 (lambda)
  On NUM        reduce rule 10 (lambda)
  On true       reduce rule 10 (lambda)
  On or         shift to state 52

State 112
  access     → ID "." ID •

  On /          reduce rule 21 (access)
  On {          reduce rule 21 (access)
  On NL         reduce rule 21 (access)
  On in         reduce rule 21 (access)
  On cond       reduce rule 21 (access)
  On >          reduce rule 21 (access)
  On do         reduce rule 21 (access)
  On and        reduce rule 21 (access)
  On false      reduce rule 21 (access)
  On [          reduce rule 21 (access)
  On not        reduce rule 21 (access)
  On +          reduce rule 21 (access)
  On nil        reduce rule 21 (access)
  On >=         reduce rule 21 (access)
  On NUM        reduce rule 21 (access)
  On or         reduce rule 21 (access)
  On -          reduce rule 21 (access)
  On (          reduce rule 21 (access)
  On <          reduce rule 21 (access)
  On if         reduce rule 21 (access)
  On ,          reduce rule 21 (access)
  On ==         reduce rule 21 (access)
  On :          reduce rule 21 (access)
  On )          reduce rule 21 (access)
  On STR        reduce rule 21 (access)
  On ID         reduce rule 21 (access)
  On *          reduce rule 21 (access)
  On #[         reduce rule 21 (access)
  On <=         reduce rule 21 (access)
  On !=         reduce rule 21 (access)
  On .          reduce rule 21 (access)
  On ->         reduce rule 21 (access)
  On true       reduce rule 21 (access)

State 113
  lambda     → ID "->" logic •
  logic      → logic • "and" equals
  logic      → logic • "or" equals

  On (          reduce rule 10 (lambda)
  On {          reduce rule 10 (lambda)
  On NL         reduce rule 10 (lambda)
  On if         reduce rule 10 (lambda)
  On ,          reduce rule 10 (lambda)
  On cond       reduce rule 10 (lambda)
  On :          reduce rule 10 (lambda)
  On do         reduce rule 10 (lambda)
  On )          reduce rule 10 (lambda)
  On STR        reduce rule 10 (lambda)
  On and        shift to state 51
  On false      reduce rule 10 (lambda)
  On ID         reduce rule 10 (lambda)
  On [          reduce rule 10 (lambda)
  On #[         reduce rule 10 (lambda)
  On not        reduce rule 10 (lambda)
  On nil        reduce rule 10 (lambda)
  On NUM        reduce rule 10 (lambda)
  On true       reduce rule 10 (lambda)
  On or         shift to state 52

State 114
  compare    → member "<" member •

  On (          reduce rule 13 (compare)
  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On do         reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On !=         reduce rule 13 (compare)
  On NUM        reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)
  On or         reduce rule 13 (compare)

State 115
  compare    → member ">" member •

  On (          reduce rule 13 (compare)
  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On do         reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On !=         reduce rule 13 (compare)
  On NUM        reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)
  On or         reduce rule 13 (compare)

State 116
  compare    → member "<=" member •

  On (          reduce rule 13 (compare)
  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On do         reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On !=         reduce rule 13 (compare)
  On NUM        reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)
  On or         reduce rule 13 (compare)

State 117
  compare    → member ">=" member •

  On (          reduce rule 13 (compare)
  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On do         reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On !=         reduce rule 13 (compare)
  On NUM        reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)
  On or         reduce rule 13 (compare)

State 118
  tuple      → "#[" items "]" •

  On /          reduce rule 32 (tuple)
  On {          reduce rule 32 (tuple)
  On NL         reduce rule 32 (tuple)
  On in         reduce rule 32 (tuple)
  On cond       reduce rule 32 (tuple)
  On >          reduce rule 32 (tuple)
  On do         reduce rule 32 (tuple)
  On and        reduce rule 32 (tuple)
  On false      reduce rule 32 (tuple)
  On [          reduce rule 32 (tuple)
  On not        reduce rule 32 (tuple)
  On +          reduce rule 32 (tuple)
  On nil        reduce rule 32 (tuple)
  On >=         reduce rule 32 (tuple)
  On NUM        reduce rule 32 (tuple)
  On or         reduce rule 32 (tuple)
  On -          reduce rule 32 (tuple)
  On (          reduce rule 32 (tuple)
  On <          reduce rule 32 (tuple)
  On if         reduce rule 32 (tuple)
  On ,          reduce rule 32 (tuple)
  On ==         reduce rule 32 (tuple)
  On :          reduce rule 32 (tuple)
  On )          reduce rule 32 (tuple)
  On STR        reduce rule 32 (tuple)
  On ID         reduce rule 32 (tuple)
  On *          reduce rule 32 (tuple)
  On #[         reduce rule 32 (tuple)
  On <=         reduce rule 32 (tuple)
  On !=         reduce rule 32 (tuple)
  On ->         reduce rule 32 (tuple)
  On true       reduce rule 32 (tuple)

State 119
  entry      → ID ":" • arg opt_comma
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 133
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 120
  clause     → logic • "->" call NL
  logic      → logic • "and" equals
  logic      → logic • "or" equals

  On and        shift to state 51
  On ->         shift to state 134
  On or         shift to state 52

State 121
  clauses    → clauses clause •

  On (          reduce rule 28 (clauses)
  On {          reduce rule 28 (clauses)
  On if         reduce rule 28 (clauses)
  On cond       reduce rule 28 (clauses)
  On :          reduce rule 28 (clauses)
  On do         reduce rule 28 (clauses)
  On STR        reduce rule 28 (clauses)
  On false      reduce rule 28 (clauses)
  On ID         reduce rule 28 (clauses)
  On [          reduce rule 28 (clauses)
  On #[         reduce rule 28 (clauses)
  On not        reduce rule 28 (clauses)
  On end        reduce rule 28 (clauses)
  On nil        reduce rule 28 (clauses)
  On NUM        reduce rule 28 (clauses)
  On true       reduce rule 28 (clauses)

State 122
  cond_block → "cond" "do" clauses "end" •

  On /          reduce rule 27 (cond_block)
  On {          reduce rule 27 (cond_block)
  On NL         reduce rule 27 (cond_block)
  On in         reduce rule 27 (cond_block)
  On cond       reduce rule 27 (cond_block)
  On >          reduce rule 27 (cond_block)
  On do         reduce rule 27 (cond_block)
  On and        reduce rule 27 (cond_block)
  On false      reduce rule 27 (cond_block)
  On [          reduce rule 27 (cond_block)
  On not        reduce rule 27 (cond_block)
  On +          reduce rule 27 (cond_block)
  On nil        reduce rule 27 (cond_block)
  On >=         reduce rule 27 (cond_block)
  On NUM        reduce rule 27 (cond_block)
  On or         reduce rule 27 (cond_block)
  On -          reduce rule 27 (cond_block)
  On (          reduce rule 27 (cond_block)
  On <          reduce rule 27 (cond_block)
  On if         reduce rule 27 (cond_block)
  On ,          reduce rule 27 (cond_block)
  On ==         reduce rule 27 (cond_block)
  On :          reduce rule 27 (cond_block)
  On )          reduce rule 27 (cond_block)
  On STR        reduce rule 27 (cond_block)
  On ID         reduce rule 27 (cond_block)
  On *          reduce rule 27 (cond_block)
  On #[         reduce rule 27 (cond_block)
  On <=         reduce rule 27 (cond_block)
  On !=         reduce rule 27 (cond_block)
  On ->         reduce rule 27 (cond_block)
  On true       reduce rule 27 (cond_block)

State 123
  opt_comma  → NL •

  On ]          reduce rule 38 (opt_comma)
  On (          reduce rule 38 (opt_comma)
  On {          reduce rule 38 (opt_comma)
  On if         reduce rule 38 (opt_comma)
  On cond       reduce rule 38 (opt_comma)
  On :          reduce rule 38 (opt_comma)
  On do         reduce rule 38 (opt_comma)
  On }          reduce rule 38 (opt_comma)
  On STR        reduce rule 38 (opt_comma)
  On false      reduce rule 38 (opt_comma)
  On ID         reduce rule 38 (opt_comma)
  On [          reduce rule 38 (opt_comma)
  On #[         reduce rule 38 (opt_comma)
  On not        reduce rule 38 (opt_comma)
  On nil        reduce rule 38 (opt_comma)
  On NUM        reduce rule 38 (opt_comma)
  On true       reduce rule 38 (opt_comma)

State 124
  opt_comma  → "," •

  On ]          reduce rule 38 (opt_comma)
  On (          reduce rule 38 (opt_comma)
  On {          reduce rule 38 (opt_comma)
  On if         reduce rule 38 (opt_comma)
  On cond       reduce rule 38 (opt_comma)
  On :          reduce rule 38 (opt_comma)
  On do         reduce rule 38 (opt_comma)
  On }          reduce rule 38 (opt_comma)
  On STR        reduce rule 38 (opt_comma)
  On false      reduce rule 38 (opt_comma)
  On ID         reduce rule 38 (opt_comma)
  On [          reduce rule 38 (opt_comma)
  On #[         reduce rule 38 (opt_comma)
  On not        reduce rule 38 (opt_comma)
  On nil        reduce rule 38 (opt_comma)
  On NUM        reduce rule 38 (opt_comma)
  On true       reduce rule 38 (opt_comma)

State 125
  item       → arg opt_comma •

  On ]          reduce rule 35 (item)
  On (          reduce rule 35 (item)
  On {          reduce rule 35 (item)
  On if         reduce rule 35 (item)
  On cond       reduce rule 35 (item)
  On :          reduce rule 35 (item)
  On do         reduce rule 35 (item)
  On STR        reduce rule 35 (item)
  On false      reduce rule 35 (item)
  On ID         reduce rule 35 (item)
  On [          reduce rule 35 (item)
  On #[         reduce rule 35 (item)
  On not        reduce rule 35 (item)
  On nil        reduce rule 35 (item)
  On NUM        reduce rule 35 (item)
  On true       reduce rule 35 (item)

State 126
  def_stmt   → "def" "(" id_list ")" • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 135
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 127
  id_list    → id_list ID •

  On )          reduce rule 7 (id_list)
  On ID         reduce rule 7 (id_list)

State 128
  assign     → ID "=" call •
  call       → call • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On NL         reduce rule 5 (assign)
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 63
  On if         shift to state 30
  On ,          reduce rule 5 (assign)
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 129
  assigns    → assigns "," assign •

  On NL         reduce rule 4 (assigns)
  On ,          reduce rule 4 (assigns)

State 130
  lambda     → "(" ")" "->" logic •
  logic      → logic • "and" equals
  logic      → logic • "or" equals

  On (          reduce rule 10 (lambda)
  On {          reduce rule 10 (lambda)
  On NL         reduce rule 10 (lambda)
  On if         reduce rule 10 (lambda)
  On ,          reduce rule 10 (lambda)
  On cond       reduce rule 10 (lambda)
  On :          reduce rule 10 (lambda)
  On do         reduce rule 10 (lambda)
  On )          reduce rule 10 (lambda)
  On STR        reduce rule 10 (lambda)
  On and        shift to state 51
  On false      reduce rule 10 (lambda)
  On ID         reduce rule 10 (lambda)
  On [          reduce rule 10 (lambda)
  On #[         reduce rule 10 (lambda)
  On not        reduce rule 10 (lambda)
  On nil        reduce rule 10 (lambda)
  On NUM        reduce rule 10 (lambda)
  On true       reduce rule 10 (lambda)
  On or         shift to state 52

State 131
  if_block   → "if" arg do_block nothing •

  On /          reduce rule 25 (if_block)
  On {          reduce rule 25 (if_block)
  On NL         reduce rule 25 (if_block)
  On in         reduce rule 25 (if_block)
  On cond       reduce rule 25 (if_block)
  On >          reduce rule 25 (if_block)
  On do         reduce rule 25 (if_block)
  On and        reduce rule 25 (if_block)
  On false      reduce rule 25 (if_block)
  On [          reduce rule 25 (if_block)
  On not        reduce rule 25 (if_block)
  On +          reduce rule 25 (if_block)
  On nil        reduce rule 25 (if_block)
  On >=         reduce rule 25 (if_block)
  On NUM        reduce rule 25 (if_block)
  On or         reduce rule 25 (if_block)
  On -          reduce rule 25 (if_block)
  On (          reduce rule 25 (if_block)
  On <          reduce rule 25 (if_block)
  On if         reduce rule 25 (if_block)
  On ,          reduce rule 25 (if_block)
  On ==         reduce rule 25 (if_block)
  On :          reduce rule 25 (if_block)
  On )          reduce rule 25 (if_block)
  On STR        reduce rule 25 (if_block)
  On ID         reduce rule 25 (if_block)
  On *          reduce rule 25 (if_block)
  On #[         reduce rule 25 (if_block)
  On <=         reduce rule 25 (if_block)
  On !=         reduce rule 25 (if_block)
  On ->         reduce rule 25 (if_block)
  On true       reduce rule 25 (if_block)

State 132
  do_else    → "do" stmts • "else" stmts "end"
  do_block   → "do" stmts • "end"
  stmts      → stmts • stmt NL
  stmt       → • let_stmt
  stmt       → • def_stmt
  stmt       → • call
  let_stmt   → • "let" assigns
  def_stmt   → • "def" "(" id_list ")" arg
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On literal    shift to state 3
  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On let_stmt   shift to state 13
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On def        shift to state 17
  On not        shift to state 18
  On end        shift to state 93
  On call       shift to state 19
  On if_block   shift to state 20
  On let        shift to state 21
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On else       shift to state 136
  On cond_block shift to state 41
  On def_stmt   shift to state 42
  On block      shift to state 43
  On tuple      shift to state 44
  On stmt       shift to state 45
  On true       shift to state 46

State 133
  entry      → ID ":" arg • opt_comma
  opt_comma  → • ","
  opt_comma  → • NL
  opt_comma  → ε •

  On ]          reduce rule 38 (opt_comma)
  On (          reduce rule 38 (opt_comma)
  On {          reduce rule 38 (opt_comma)
  On NL         shift to state 123
  On if         reduce rule 38 (opt_comma)
  On ,          shift to state 124
  On cond       reduce rule 38 (opt_comma)
  On :          reduce rule 38 (opt_comma)
  On do         reduce rule 38 (opt_comma)
  On }          reduce rule 38 (opt_comma)
  On STR        reduce rule 38 (opt_comma)
  On false      reduce rule 38 (opt_comma)
  On ID         reduce rule 38 (opt_comma)
  On [          reduce rule 38 (opt_comma)
  On #[         reduce rule 38 (opt_comma)
  On not        reduce rule 38 (opt_comma)
  On nil        reduce rule 38 (opt_comma)
  On opt_comma  shift to state 137
  On NUM        reduce rule 38 (opt_comma)
  On true       reduce rule 38 (opt_comma)

State 134
  clause     → logic "->" • call NL
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On call       shift to state 138
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 135
  def_stmt   → "def" "(" id_list ")" arg •

  On NL         reduce rule 6 (def_stmt)

State 136
  do_else    → "do" stmts "else" • stmts "end"
  stmts      → • stmts stmt NL
  stmts      → • NL
  stmts      → ε •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On NL         shift to state 1
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On stmts      shift to state 139
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 137
  entry      → ID ":" arg opt_comma •

  On }          reduce rule 37 (entry)
  On ID         reduce rule 37 (entry)

State 138
  clause     → logic "->" call • NL
  call       → call • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On NL         shift to state 140
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 63
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 139
  do_else    → "do" stmts "else" stmts • "end"
  stmts      → stmts • stmt NL
  stmt       → • let_stmt
  stmt       → • def_stmt
  stmt       → • call
  let_stmt   → • "let" assigns
  def_stmt   → • "def" "(" id_list ")" arg
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • ID "->" logic
  lambda     → • group "->" logic
  lambda     → • "(" ")" "->" logic
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  if_block   → • "if" arg do_block nothing
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On literal    shift to state 3
  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On let_stmt   shift to state 13
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On def        shift to state 17
  On not        shift to state 18
  On end        shift to state 141
  On call       shift to state 19
  On if_block   shift to state 20
  On let        shift to state 21
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On def_stmt   shift to state 42
  On block      shift to state 43
  On tuple      shift to state 44
  On stmt       shift to state 45
  On true       shift to state 46

State 140
  clause     → logic "->" call NL •

  On (          reduce rule 29 (clause)
  On {          reduce rule 29 (clause)
  On if         reduce rule 29 (clause)
  On cond       reduce rule 29 (clause)
  On :          reduce rule 29 (clause)
  On do         reduce rule 29 (clause)
  On STR        reduce rule 29 (clause)
  On false      reduce rule 29 (clause)
  On ID         reduce rule 29 (clause)
  On [          reduce rule 29 (clause)
  On #[         reduce rule 29 (clause)
  On not        reduce rule 29 (clause)
  On end        reduce rule 29 (clause)
  On nil        reduce rule 29 (clause)
  On NUM        reduce rule 29 (clause)
  On true       reduce rule 29 (clause)

State 141
  do_else    → "do" stmts "else" stmts "end" •

  On /          reduce rule 26 (do_else)
  On {          reduce rule 26 (do_else)
  On NL         reduce rule 26 (do_else)
  On in         reduce rule 26 (do_else)
  On cond       reduce rule 26 (do_else)
  On >          reduce rule 26 (do_else)
  On do         reduce rule 26 (do_else)
  On and        reduce rule 26 (do_else)
  On false      reduce rule 26 (do_else)
  On [          reduce rule 26 (do_else)
  On not        reduce rule 26 (do_else)
  On +          reduce rule 26 (do_else)
  On nil        reduce rule 26 (do_else)
  On >=         reduce rule 26 (do_else)
  On NUM        reduce rule 26 (do_else)
  On or         reduce rule 26 (do_else)
  On -          reduce rule 26 (do_else)
  On (          reduce rule 26 (do_else)
  On <          reduce rule 26 (do_else)
  On if         reduce rule 26 (do_else)
  On ,          reduce rule 26 (do_else)
  On ==         reduce rule 26 (do_else)
  On :          reduce rule 26 (do_else)
  On )          reduce rule 26 (do_else)
  On STR        reduce rule 26 (do_else)
  On ID         reduce rule 26 (do_else)
  On *          reduce rule 26 (do_else)
  On #[         reduce rule 26 (do_else)
  On <=         reduce rule 26 (do_else)
  On !=         reduce rule 26 (do_else)
  On ->         reduce rule 26 (do_else)
  On true       reduce rule 26 (do_else)

┌╴Actions╶───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│  -1   1  -1   .  -1   .  -1  -1   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -1  -1  -1  -1  -1  -1  -1   .  -1  -1  -1  -1  -1  -1   .  -1  -1   .│
│  -1   .  -1   .  -1   .  -1  -1   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -1  -1  -1  -1  -1  -1  -1   .  -1  -1  -1  -1  -1  -1   .  -1  -1   .│
│  39   .  21   .  35   .  17  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18   .│
│   . -14   . -14 -14   .   . -14 -14 -14 -14 -14 -14 -14 -14 -14 -14 -14  48  49  47   .   . -14 -14 -14 -14 -14 -14 -14   . -14   . -14   . -14 -14   . -14 -14   .│
│   .   .   .   . -36   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -36│
│   . -23   . -23 -23   .   . -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23   . -23   . -23   . -23 -23   . -23 -23   .│
│   . -10   . -10 -10   .   . -10 -10   .  51  52   .   .   .   .   .   .   .   .   .   .   . -10 -10 -10 -10 -10 -10 -10   . -10   . -10   . -10 -10   . -10 -10   .│
│   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  53   .   .   .   .   .   .   .   .   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18   .│
│  -1   1  -1   .  -1   .  -1  -1   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -1  -1  -1  -1  -1  -1  -1   .  -1  -1  -1  -1  -1  -1   .  -1  -1   .│
│   . -15   . -15 -15   .   . -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15  56  55 -15 -15 -15 -15 -15 -15 -15   . -15   . -15   . -15 -15   . -15 -15   .│
│   . -30   . -30 -30   .   . -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30   . -30   . -30   . -30 -30   . -30 -30   .│
│   .  -2   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   . -19   . -19 -19   .   . -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19   . -19   . -19   . -19 -19   . -19 -19   .│
│   . -11   . -11 -11   .   . -11 -11 -11 -11 -11   .   .   .   .   .   .   .   .   .   .   . -11 -11 -11 -11 -11 -11 -11   . -11   . -11   . -11 -11   . -11 -11   .│
│   .   .   .   . -34   .   . -34   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -34 -34 -34 -34 -34 -34 -34   . -34   . -34   . -34 -34 -34 -34 -34   .│
│   .   .   .   .   .   .   .  58   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .  -2   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   . -23   . -23 -23   .   . -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23   . -23   . -23   . -23 -23   . -23 -23   .│
│   .   .   .   .  65   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   . -19   . -19 -19   .   . -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19   . -19   . -19   . -19 -19   . -19 -19   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18  67 -18   . -18   . -18 -18   . -18 -18   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18   .│
│   . -16   . -16 -16   .   . -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16   . -16   . -16   . -16 -16   . -16 -16   .│
│   . -12   . -12 -12   .   . -12 -12 -12 -12 -12  68  69   .   .   .   .   .   .   .   .   . -12 -12 -12 -12 -12 -12 -12   . -12   . -12   . -12 -12   . -12 -12   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18   .│
│   .   .   .   .  35   .   .  28  71   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .  -8   .  -8  -8   .   .  -8  -8   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -8  -8  -8  -8  -8  -8  -8   .  -8   .  -8   .  -8  -8   .  -8  -8   .│
│   .   .   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  73   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   . -18   . -18 -18   .   . -18 -18  74 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18   .│
│   . -17   . -17 -17   .   . -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17   . -17   . -17   . -17 -17   . -17 -17   .│
│   . -18   . -18 -18   .   . -18 -18  76 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18  75 -18   . -18   . -18 -18   . -18 -18   .│
│   . -13   . -13 -13   .   . -13 -13 -13 -13 -13 -13 -13  78  80  77  79   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13   .│
│   .   .   .   . -34   .   . -34   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -34 -34 -34 -34 -34 -34 -34   . -34   . -34   . -34 -34 -34 -34 -34   .│
│   . -30   . -30 -30   .   . -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30   . -30   . -30   . -30 -30   . -30 -30   .│
│   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .  -9   .  -9  -9   .   .  -9  -9   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -9  -9  -9  -9  -9  -9  -9   .  -9   .  -9   .  -9  -9   .  -9  -9   .│
│   . -23   . -23 -23   .   . -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23   . -23   . -23   . -23 -23   . -23 -23   .│
│   .  -2   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18   .│
│   . -30   . -30 -30   .   . -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30   . -30   . -30   . -30 -30   . -30 -30   .│
│   .  82   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   . -19   . -19 -19   .   . -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19   . -19   . -19   . -19 -19   . -19 -19   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  88   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  87│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .  92   .   . -28   .   . -28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -28 -28 -28 -28 -28 -28 -28   . -28 -28 -28   . -28 -28   . -28 -28   .│
│   .   .  21   .  35   .  17  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10  93  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16  96  37   5   .│
│   .   .   .   . 100   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18   .│
│   . -17   . -17 -17   .   . -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17   . -17   . -17   . -17 -17   . -17 -17   .│
│   . -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18  75 -18   . -18   . -18 -18   . -18 -18   .│
│   .  -8   .  -8  -8   .   .  -8  -8   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -8  -8  -8  -8  -8  -8  -8   .  -8   .  -8   .  -8  -8   .  -8  -8   .│
│   .  -4   .  -4   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   .   . 101   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .  -3   . 102   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   . 103   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  35   .   .  28 106   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .   .   .   .   .   . 107   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 110   .   .   .   .   .   .   .   .   .│
│   . -20   . -20 -20   .   . -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20   . -20   . -20   . -20 -20   . -20 -20   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   . 112   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16 118  37   5   .│
│  -1   .  -1   .  -1   .  -1  -1   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -1  -1  -1  -1  -1  -1  -1   .  -1  -1  -1  -1  -1  -1   .  -1  -1   .│
│   . -15   . -15 -15   .   . -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15  56  55 -15 -15 -15 -15 -15 -15 -15   . -15   . -15   . -15 -15   . -15 -15   .│
│   . -14   . -14 -14   .   . -14 -14 -14 -14 -14 -14 -14 -14 -14 -14 -14   .  49  47   .   . -14 -14 -14 -14 -14 -14 -14   . -14   . -14   . -14 -14   . -14 -14   .│
│   . -15   . -15 -15   .   . -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15  56  55 -15 -15 -15 -15 -15 -15 -15   . -15   . -15   . -15 -15   . -15 -15   .│
│   .   .   .   . -36   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -36│
│   . -33   . -33 -33   .   . -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33   . -33   . -33   . -33 -33   . -33 -33   .│
│   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 119   .   .   .   .   .   .   .   .   .   .   .│
│   . -11   . -11 -11   .   . -11 -11 -11 -11 -11   .   .   .   .   .   .   .   .   .   .   . -11 -11 -11 -11 -11 -11 -11   . -11   . -11   . -11 -11   . -11 -11   .│
│   . -11   . -11 -11   .   . -11 -11 -11 -11 -11   .   .   .   .   .   .   .   .   .   .   . -11 -11 -11 -11 -11 -11 -11   . -11   . -11   . -11 -11   . -11 -11   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10 122  30   .   8  16   .  37   5   .│
│   .   .   .   . -28   .   . -28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -28 -28 -28 -28 -28 -28 -28   . -28 -28 -28   . -28 -28   . -28 -28   .│
│   . -24   . -24 -24   .   . -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24   . -24   . -24   . -24 -24   . -24 -24   .│
│   . -16   . -16 -16   .   . -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16   . -16   . -16   . -16 -16   . -16 -16   .│
│   . -16   . -16 -16   .   . -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16   . -16   . -16   . -16 -16   . -16 -16   .│
│   . -31   . -31 -31   .   . -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31   . -31   . -31   . -31 -31   . -31 -31   .│
│   . 123   . 124 -38   .   . -38   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -38 -38 -38 -38 -38 -38 -38   . -38   . -38   . -38 -38 -38 -38 -38 -38│
│   .   .   .   . -34   .   . -34   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -34 -34 -34 -34 -34 -34 -34   . -34   . -34   . -34 -34 -34 -34 -34   .│
│   .   .   .   . 127   .   .   . 126   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   .  -7   .   .   .  -7   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  65   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   . -21   . -21 -21   .   . -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21   . -21   . -21 -21   . -21 -21   .│
│   . -12   . -12 -12   .   . -12 -12 -12 -12 -12   .   .   .   .   .   .   .   .   .   .   . -12 -12 -12 -12 -12 -12 -12   . -12   . -12   . -12 -12   . -12 -12   .│
│   . -12   . -12 -12   .   . -12 -12 -12 -12 -12   .   .   .   .   .   .   .   .   .   .   . -12 -12 -12 -12 -12 -12 -12   . -12   . -12   . -12 -12   . -12 -12   .│
│   . -22   . -22 -22   .   . -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22   . -22   . -22   . -22 -22   . -22 -22   .│
│   .   .   .   .  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   . -39   . -39 -39   .   . -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39   . -39   . -39   . -39 -39   . -39 -39   .│
│   . -25   . -25 -25   .   . -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25   . -25   . -25   . -25 -25   . -25 -25   .│
│  -1   1  -1   .  -1   .  -1  -1   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -1  -1  -1  -1  -1  -1  -1   .  -1  -1  -1  -1  -1  -1   .  -1  -1   .│
│   . -10   . -10 -10   .   . -10 -10   .  51  52   .   .   .   .   .   .   .   .   .   .   . -10 -10 -10 -10 -10 -10 -10   . -10   . -10   . -10 -10   . -10 -10   .│
│   . -21   . -21 -21   .   . -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21   . -21   . -21 -21   . -21 -21   .│
│   . -10   . -10 -10   .   . -10 -10   .  51  52   .   .   .   .   .   .   .   .   .   .   . -10 -10 -10 -10 -10 -10 -10   . -10   . -10   . -10 -10   . -10 -10   .│
│   . -13   . -13 -13   .   . -13 -13 -13 -13 -13 -13 -13   .   .   .   .   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13   .│
│   . -13   . -13 -13   .   . -13 -13 -13 -13 -13 -13 -13   .   .   .   .   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13   .│
│   . -13   . -13 -13   .   . -13 -13 -13 -13 -13 -13 -13   .   .   .   .   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13   .│
│   . -13   . -13 -13   .   . -13 -13 -13 -13 -13 -13 -13   .   .   .   .   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13   .│
│   . -32   . -32 -32   .   . -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32   . -32   . -32   . -32 -32   . -32 -32   .│
│   .   .   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .   .   .   .   .   . 134  51  52   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .   . -28   .   . -28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -28 -28 -28 -28 -28 -28 -28   . -28 -28 -28   . -28 -28   . -28 -28   .│
│   . -27   . -27 -27   .   . -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27   . -27   . -27   . -27 -27   . -27 -27   .│
│   .   .   .   . -38   .   . -38   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -38 -38 -38 -38 -38 -38 -38   . -38   . -38   . -38 -38 -38 -38 -38 -38│
│   .   .   .   . -38   .   . -38   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -38 -38 -38 -38 -38 -38 -38   . -38   . -38   . -38 -38 -38 -38 -38 -38│
│   .   .   .   . -35   .   . -35   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -35 -35 -35 -35 -35 -35 -35   . -35   . -35   . -35 -35 -35 -35 -35   .│
│   .   .   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .   .   .  -7   .   .   .  -7   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .  -5   .  -5  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .  -4   .  -4   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   . -10   . -10 -10   .   . -10 -10   .  51  52   .   .   .   .   .   .   .   .   .   .   . -10 -10 -10 -10 -10 -10 -10   . -10   . -10   . -10 -10   . -10 -10   .│
│   . -25   . -25 -25   .   . -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25   . -25   . -25   . -25 -25   . -25 -25   .│
│   .   .  21   .  35   .  17  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10  93  30 136   8  16   .  37   5   .│
│   . 123   . 124 -38   .   . -38   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -38 -38 -38 -38 -38 -38 -38   . -38   . -38   . -38 -38 -38 -38 -38 -38│
│   .   .   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .  -6   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│  -1   1  -1   .  -1   .  -1  -1   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -1  -1  -1  -1  -1  -1  -1   .  -1  -1  -1  -1  -1  -1   .  -1  -1   .│
│   .   .   .   . -37   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -37│
│   . 140   .   .  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5   .│
│   .   .  21   .  35   .  17  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10 141  30   .   8  16   .  37   5   .│
│   .   .   .   . -29   .   . -29   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -29 -29 -29 -29 -29 -29 -29   . -29 -29 -29   . -29 -29   . -29 -29   .│
│   . -26   . -26 -26   .   . -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26   . -26   . -26   . -26 -26   . -26 -26   .│
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
┌╴Offsets╶───────────────────────────────┐
│   0  -1  -1  39  78   1 117 156 -28 195│
│  -1 234 273   7 312 351 381   2 417 450│
│ 489   6 528 567 606 645 684 723 756 795│
│ 825   7 864 903 942 981102010501089  -1│
│11281167  1112061245  121284131413441374│
│  331404143414671505153515651595  101631│
│1670170917481787  14  11  17  1518171847│
│1880  12  -919191949  261979200920392069│
│20992129  -1216822072246  402285  162324│
│236323932423246225012540257926182655 104│
│ 1112691  652730276928082847287729162955│
│  -1299430333072311131503189322832673297│
│ 159332733663396343334703506 1433545 170│
│35843623366137003737  70  -1 11837703808│
│38383877                                │
└────────────────────────────────────────┘
┌╴Compressed╶────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│  -1   1  -1  53  -1 -36  -1  -1  -2  58  65  73  -2  82 100  -4 101  -4  -3 103 102 107 110  -1  -1  -1  -1  -1  -1  -1 112  -1  -1  -1  -1  -1  -1  88  -1  -1 -18│
│ -36 -18 -18 -36 119 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18  65 -18  -6 -18  87 -18 -18   . -18 -18 -14 -36 -14│
│ -14   .   . -14 -14 -14 -14 -14 -14 -14 -14 -14 -14 -14  48  49  47   .   . -14 -14 -14 -14 -14 -14 -14 127 -14   . -14 126 -14 -14  -7 -14 -14 -23  -7 -23 -23 -37│
│   . -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23  -7 -23   . -23  -7 -23 -23   . -23 -23 -10 -37 -10 -10   .   . -10│
│ -10   .  51  52 134  51  52  -4   .  -4   .   .   .   .   . -10 -10 -10 -10 -10 -10 -10   . -10   . -10   . -10 -10   . -10 -10 -18   . -18 -18   .   . -18 -18 -18│
│ -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18 -15   . -15 -15   .   . -15 -15 -15 -15 -15│
│ -15 -15 -15 -15 -15 -15 -15 -15 -15  56  55 -15 -15 -15 -15 -15 -15 -15   . -15   . -15   . -15 -15   . -15 -15 -30   . -30 -30   .   . -30 -30 -30 -30 -30 -30 -30│
│ -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30   . -30   . -30   . -30 -30   . -30 -30 -19   . -19 -19   .   . -19 -19 -19 -19 -19 -19 -19 -19 -19│
│ -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19   . -19   . -19   . -19 -19   . -19 -19 -11   . -11 -11   .   . -11 -11 -11 -11 -11   .   .   .   .   .   .│
│   .   .   .   .   . -11 -11 -11 -11 -11 -11 -11   . -11   . -11 -34 -11 -11 -34 -11 -11   .   .   .   .   .   .   .   .   .   .   .   .   . -34 -34 -34 -34 -34 -34│
│ -34   . -34   . -34   . -34 -34 -34 -34 -34  62   .   .  59   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  24  33  46  14  22  31   .  10   .  30│
│  -2   8  16  35  37   5  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5 -23   .│
│ -23 -23   .   . -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23   . -23   . -23   . -23 -23   . -23 -23 -19   . -19 -19│
│   .   . -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19   . -19   . -19   . -19 -19   . -19 -19 -18   . -18 -18   .   .│
│ -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18  67 -18   . -18   . -18 -18   . -18 -18 -18   . -18 -18   .   . -18 -18│
│ -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18 -16   . -16 -16   .   . -16 -16 -16 -16│
│ -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16   . -16   . -16   . -16 -16   . -16 -16 -12   . -12 -12   .   . -12 -12 -12 -12 -12  68│
│  69   .   .   .   .   .   .   .   .   . -12 -12 -12 -12 -12 -12 -12   . -12   . -12   . -12 -12   . -12 -12 -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18│
│ -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18  35 -18 -18  28  71   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5  -8   .  -8  -8   .   .  -8  -8   .   .   .   .   .   .   .   .   .   .   .   .   .   .  -8  -8│
│  -8  -8  -8  -8  -8   .  -8   .  -8  35  -8  -8  28  -8  -8   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8│
│  16   .  37   5 -18   . -18 -18   .   . -18 -18  74 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   .│
│ -18 -18 -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18│
│ -17   . -17 -17   .   . -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17   . -17   . -17   . -17 -17   . -17 -17 -18   .│
│ -18 -18   .   . -18 -18  76 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18  75 -18   . -18   . -18 -18   . -18 -18 -13   . -13 -13│
│   .   . -13 -13 -13 -13 -13 -13 -13  78  80  77  79   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13 -34 -13 -13 -34 -13 -13   .   .   .   .   .   .│
│   .   .   .   .   .   .   . -34 -34 -34 -34 -34 -34 -34   . -34   . -34   . -34 -34 -34 -34 -34 -30   . -30 -30   .   . -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30│
│ -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30   . -30   . -30   . -30 -30   . -30 -30  -9   .  -9  -9   .   .  -9  -9   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .  -9  -9  -9  -9  -9  -9  -9   .  -9   .  -9   .  -9  -9   .  -9  -9 -23   . -23 -23   .   . -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23 -23│
│ -23 -23 -23 -23 -23 -23 -23 -23   . -23   . -23   . -23 -23   . -23 -23 -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18│
│ -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18 -30   . -30 -30   .   . -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30 -30│
│ -30 -30 -30 -30   . -30   . -30   . -30 -30   . -30 -30 -19   . -19 -19   .   . -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19 -19│
│ -19 -19   . -19   . -19  62 -19 -19  59 -19 -19   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30  62   8  16  59  37│
│   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .│
│   .   .   .  18  24  33  46  14  22  31   .  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .│
│  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30  92   8  16 -28  37   5 -28   .│
│   .   .   .   .   .   .   .   .   .   .   .   .   .   . -28 -28 -28 -28 -28 -28 -28   . -28 -28 -28   . -28 -28   . -28 -28  21   .  35   .  17  28   .   .   .   .│
│   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10  93  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .│
│  18  24  33  46  14  22  31   .  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30│
│  35   8  16  28  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16  96  37   5  35   .   .  28   .│
│   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5 -18   . -18 -18   .   . -18 -18 -18 -18│
│ -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18   . -18   . -18   . -18 -18   . -18 -18 -17   . -17 -17   .   . -17 -17 -17 -17 -17 -17│
│ -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17 -17   . -17   . -17   . -17 -17   . -17 -17 -18   . -18 -18   .   . -18 -18 -18 -18 -18 -18 -18 -18│
│ -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18 -18  75 -18   . -18   . -18 -18   . -18 -18  -8   .  -8  -8   .   .  -8  -8   .   .   .   .   .   .   .   .│
│   .   .   .   .   .   .  -8  -8  -8  -8  -8  -8  -8   .  -8   .  -8  62  -8  -8  59  -8  -8   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14│
│  22  31   .  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16  35  37│
│   5  28 106   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5 -20   . -20 -20   .   . -20│
│ -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20   . -20   . -20  62 -20 -20  59 -20 -20   .   .   .   .   .   .   .   .   .│
│   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31│
│   .  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30  62   8  16  59  37   5   .│
│   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .│
│   .  18  24  33  46  14  22  31   .  10   .  30  62   8  16  59  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .│
│  30  35   8  16  28  37   5   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16 118  37   5 -15   . -15 -15│
│   .   . -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15  56  55 -15 -15 -15 -15 -15 -15 -15   . -15   . -15   . -15 -15   . -15 -15 -14   . -14 -14   .   .│
│ -14 -14 -14 -14 -14 -14 -14 -14 -14 -14 -14   .  49  47   .   . -14 -14 -14 -14 -14 -14 -14   . -14   . -14   . -14 -14   . -14 -14 -15   . -15 -15   .   . -15 -15│
│ -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15 -15  56  55 -15 -15 -15 -15 -15 -15 -15   . -15   . -15   . -15 -15   . -15 -15 -33   . -33 -33   .   . -33 -33 -33 -33│
│ -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33 -33   . -33   . -33   . -33 -33   . -33 -33 -11   . -11 -11   .   . -11 -11 -11 -11 -11   .│
│   .   .   .   .   .   .   .   .   .   . -11 -11 -11 -11 -11 -11 -11   . -11   . -11   . -11 -11   . -11 -11 -11   . -11 -11   .   . -11 -11 -11 -11 -11   .   .   .│
│   .   .   .   .   .   .   .   . -11 -11 -11 -11 -11 -11 -11   . -11   . -11  62 -11 -11  59 -11 -11   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33│
│  46  14  22  31   .  10 122  30 -28   8  16 -28  37   5   .   .   .   .   .   .   .   .   .   .   .   .   . -28 -28 -28 -28 -28 -28 -28   . -28 -28 -28   . -28 -28│
│   . -28 -28 -24   . -24 -24   .   . -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24 -24   . -24   . -24   . -24 -24   . -24│
│ -24 -16   . -16 -16   .   . -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16   . -16   . -16   . -16 -16   . -16 -16 -16│
│   . -16 -16   .   . -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16 -16   . -16   . -16   . -16 -16   . -16 -16 -31   . -31│
│ -31   .   . -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31 -31   . -31   . -31   . -31 -31   . -31 -31 123   . 124 -38   .│
│   . -38   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -38 -38 -38 -38 -38 -38 -38   . -38   . -38   . -38 -38 -38 -38 -38 -38 -34   .   . -34   .   .│
│   .   .   .   .   .   .   .   .   .   .   .   .   . -34 -34 -34 -34 -34 -34 -34   . -34   . -34   . -34 -34 -34 -34 -34  35   .   .  28   .   .   .   .   .   .   .│
│   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5 -21   . -21 -21   .   . -21 -21 -21 -21 -21 -21 -21 -21 -21 -21│
│ -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21   . -21   . -21 -21   . -21 -21 -12   . -12 -12   .   . -12 -12 -12 -12 -12   .   .   .   .   .   .   .│
│   .   .   .   . -12 -12 -12 -12 -12 -12 -12   . -12   . -12   . -12 -12   . -12 -12 -12   . -12 -12   .   . -12 -12 -12 -12 -12   .   .   .   .   .   .   .   .   .│
│   .   . -12 -12 -12 -12 -12 -12 -12   . -12   . -12   . -12 -12   . -12 -12 -22   . -22 -22   .   . -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22 -22│
│ -22 -22 -22 -22 -22 -22 -22   . -22   . -22  62 -22 -22  59 -22 -22   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30│
│   .   8  16   .  37   5 -39   . -39 -39   .   . -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39 -39   . -39   . -39   . -39│
│ -39   . -39 -39 -25   . -25 -25   .   . -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25   . -25   . -25   . -25 -25   .│
│ -25 -25 -10   . -10 -10   .   . -10 -10   .  51  52   .   .   .   .   .   .   .   .   .   .   . -10 -10 -10 -10 -10 -10 -10   . -10   . -10   . -10 -10   . -10 -10│
│ -21   . -21 -21   .   . -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21 -21   . -21   . -21 -21   . -21 -21 -10   .│
│ -10 -10   .   . -10 -10   .  51  52   .   .   .   .   .   .   .   .   .   .   . -10 -10 -10 -10 -10 -10 -10   . -10   . -10   . -10 -10   . -10 -10 -13   . -13 -13│
│   .   . -13 -13 -13 -13 -13 -13 -13   .   .   .   .   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13 -13   . -13 -13   .   .│
│ -13 -13 -13 -13 -13 -13 -13   .   .   .   .   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13 -13   . -13 -13   .   . -13 -13│
│ -13 -13 -13 -13 -13   .   .   .   .   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13 -13   . -13 -13   .   . -13 -13 -13 -13│
│ -13 -13 -13   .   .   .   .   .   .   .   .   . -13 -13 -13 -13 -13 -13 -13   . -13   . -13   . -13 -13   . -13 -13 -32   . -32 -32   .   . -32 -32 -32 -32 -32 -32│
│ -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32 -32   . -32   . -32  35 -32 -32  28 -32 -32   .   .   .   .   .   .   .   .   .   .   .   .   .  18│
│  24  33  46  14  22  31   .  10   .  30 -28   8  16 -28  37   5   .   .   .   .   .   .   .   .   .   .   .   .   . -28 -28 -28 -28 -28 -28 -28   . -28 -28 -28   .│
│ -28 -28   . -28 -28 -27   . -27 -27   .   . -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27 -27   . -27   . -27 -38 -27 -27│
│ -38 -27 -27   .   .   .   .   .   .   .   .   .   .   .   .   . -38 -38 -38 -38 -38 -38 -38   . -38   . -38   . -38 -38 -38 -38 -38 -38 -38   .   . -38   .   .   .│
│   .   .   .   .   .   .   .   .   .   .   .   . -38 -38 -38 -38 -38 -38 -38   . -38   . -38   . -38 -38 -38 -38 -38 -38 -35   .   . -35   .   .   .   .   .   .   .│
│   .   .   .   .   .   .   .   . -35 -35 -35 -35 -35 -35 -35   . -35   . -35   . -35 -35 -35 -35 -35  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .│
│   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5  -5   .  -5  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .│
│   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5 -10   . -10 -10   .   . -10 -10   .  51  52   .   .   .   .   .   .   .   .   .   .   . -10│
│ -10 -10 -10 -10 -10 -10   . -10   . -10   . -10 -10   . -10 -10 -25   . -25 -25   .   . -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25 -25│
│ -25 -25 -25 -25   . -25   . -25   . -25 -25   . -25 -25  21   .  35   .  17  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22│
│  31   .  10  93  30 136   8  16   .  37   5 123   . 124 -38   .   . -38   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . -38 -38 -38 -38 -38 -38 -38   .│
│ -38   . -38   . -38 -38 -38 -38 -38 -38  35   .   .  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30 140│
│   8  16  35  37   5  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10   .  30   .   8  16   .  37   5  21   .  35│
│   .  17  28   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  18  24  33  46  14  22  31   .  10 141  30 -29   8  16 -29  37   5   .   .   .   .   .   .│
│   .   .   .   .   .   .   . -29 -29 -29 -29 -29 -29 -29   . -29 -29 -29   . -29 -29   . -29 -29 -26   . -26 -26   .   . -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26│
│ -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26 -26   . -26   . -26   . -26 -26   . -26 -26                                                                            │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
