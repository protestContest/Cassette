  0 program     →  stmts $
  1 stmts       →  stmts stmt NL
  2 stmts       →  NL
  3 stmts       →  ε
  4 stmt        →  let_stmt
  5 stmt        →  def_stmt
  6 stmt        →  call
  7 let_stmt    →  "let" assigns
  8 assigns     →  assigns "," assign
  9 assigns     →  assign
 10 assign      →  ID "=" call
 11 def_stmt    →  "def" "(" id_list ")" arg
 12 id_list     →  id_list ID
 13 id_list     →  ID
 14 call        →  call arg
 15 call        →  arg
 16 arg         →  lambda
 17 lambda      →  group "->" lambda
 18 lambda      →  logic
 19 logic       →  logic "and" equals
 20 logic       →  logic "or" equals
 21 logic       →  equals
 22 equals      →  compare "==" compare
 23 equals      →  compare "!=" compare
 24 equals      →  compare
 25 compare     →  member ">" member
 26 compare     →  member ">=" member
 27 compare     →  member "<" member
 28 compare     →  member "<=" member
 29 compare     →  member
 30 member      →  sum "in" sum
 31 member      →  sum
 32 sum         →  sum "+" product
 33 sum         →  sum "-" product
 34 sum         →  product
 35 product     →  product "*" unary
 36 product     →  product "/" unary
 37 product     →  unary
 38 unary       →  "not" primary
 39 unary       →  primary
 40 primary     →  NUM
 41 primary     →  ID
 42 primary     →  STR
 43 primary     →  literal
 44 primary     →  symbol
 45 primary     →  access
 46 primary     →  group
 47 primary     →  block
 48 primary     →  object
 49 literal     →  "true"
 50 literal     →  "false"
 51 literal     →  "nil"
 52 symbol      →  ":" ID
 53 access      →  access "." ID
 54 access      →  ID "." ID
 55 group       →  "(" call ")"
 56 block       →  do_block
 57 block       →  if_block
 58 block       →  cond_block
 59 do_block    →  "do" stmts "end"
 60 if_block    →  "if" arg do_else
 61 do_else     →  "do" stmts "else" stmts "end"
 62 cond_block  →  "cond" "do" clauses "end"
 63 clauses     →  clauses clause
 64 clauses     →  NL
 65 clauses     →  ε
 66 clause      →  logic "->" call NL
 67 object      →  list
 68 object      →  tuple
 69 object      →  map
 70 list        →  "[" items "]"
 71 tuple       →  "#[" items "]"
 72 map         →  "{" entries "}"
 73 items       →  items item
 74 items       →  ε
 75 item        →  arg opt_comma
 76 entries     →  entries entry
 77 entries     →  ε
 78 entry       →  ID ":" arg opt_comma
 79 opt_comma   →  ","
 80 opt_comma   →  NL
 81 opt_comma   →  ε
 82 nothing     →  ε
  0 program
    First: NL 
    Follow: 
  1 stmts
    First: NL 
    Follow: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "def" "#[" "not" $ "end" "let" "else" "nil" NUM "true" 
  2 stmt
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "def" "#[" "not" "let" "nil" NUM "true" 
    Follow: NL 
  3 let_stmt
    First: "let" 
    Follow: NL 
  4 assigns
    First: ID 
    Follow: NL "," 
  5 assign
    First: ID 
    Follow: NL "," 
  6 def_stmt
    First: "def" 
    Follow: NL 
  7 id_list
    First: ID 
    Follow: ")" ID 
  8 call
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
  9 arg
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 10 lambda
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 11 logic
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "and" "false" ID "[" "#[" "not" "nil" NUM "->" "true" "or" 
 12 equals
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" ":" "do" ")" STR "and" "false" ID "[" "#[" "not" "nil" NUM "->" "true" "or" 
 13 compare
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" NL "if" "," "cond" "==" ":" "do" ")" STR "and" "false" ID "[" "#[" "not" "nil" "!=" NUM "->" "true" "or" 
 14 member
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "{" NL "cond" ">" "do" "and" "false" "[" "not" "nil" ">=" NUM "or" "(" "<" "if" "," "==" ":" ")" STR ID "#[" "<=" "!=" "->" "true" 
 15 sum
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "#[" "<=" "!=" "->" "true" 
 16 product
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 17 unary
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 18 primary
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "nil" NUM "true" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 19 literal
    First: "false" "nil" "true" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 20 symbol
    First: ":" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 21 access
    First: ID 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "." "->" "true" 
 22 group
    First: "(" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 23 block
    First: "if" "cond" "do" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 24 do_block
    First: "do" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 25 if_block
    First: "if" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 26 do_else
    First: "do" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 27 cond_block
    First: "cond" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 28 clauses
    First: NL 
    Follow: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "end" "nil" NUM "true" 
 29 clause
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "end" "nil" NUM "true" 
 30 object
    First: "{" "[" "#[" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 31 list
    First: "[" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 32 tuple
    First: "#[" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 33 map
    First: "{" 
    Follow: "/" "{" NL "in" "cond" ">" "do" "and" "false" "[" "not" "+" "nil" ">=" NUM "or" "-" "(" "<" "if" "," "==" ":" ")" STR ID "*" "#[" "<=" "!=" "->" "true" 
 34 items
    First: 
    Follow: "]" "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 35 item
    First: "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
    Follow: "]" "(" "{" "if" "cond" ":" "do" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 36 entries
    First: 
    Follow: "}" ID 
 37 entry
    First: ID 
    Follow: "}" ID 
 38 opt_comma
    First: NL "," 
    Follow: "]" "(" "{" "if" "cond" ":" "do" "}" STR "false" ID "[" "#[" "not" "nil" NUM "true" 
 39 nothing
    First: 
    Follow: 
 40 $
 41 NL
 42 "let"
 43 ","
 44 ID
 45 "="
 46 "def"
 47 "("
 48 ")"
 49 "->"
 50 "and"
 51 "or"
 52 "=="
 53 "!="
 54 ">"
 55 ">="
 56 "<"
 57 "<="
 58 "in"
 59 "+"
 60 "-"
 61 "*"
 62 "/"
 63 "not"
 64 NUM
 65 STR
 66 "true"
 67 "false"
 68 "nil"
 69 ":"
 70 "."
 71 "do"
 72 "end"
 73 "if"
 74 "else"
 75 "cond"
 76 "["
 77 "]"
 78 "#["
 79 "{"
 80 "}"
State 0
  program    → • stmts $
  stmts      → • stmts stmt NL
  stmts      → • NL
  stmts      → ε •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On NL         shift to state 1
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On stmts      shift to state 2
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 1
  stmts      → NL •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 2
  program    → stmts • $
  stmts      → stmts • stmt NL
  stmt       → • let_stmt
  stmt       → • def_stmt
  stmt       → • call
  let_stmt   → • "let" assigns
  def_stmt   → • "def" "(" id_list ")" arg
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On literal    shift to state 3
  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On let_stmt   shift to state 13
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On def        shift to state 17
  On not        shift to state 18
  On call       shift to state 19
  On if_block   shift to state 20
  On let        shift to state 21
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On $          shift to state 39
  On lambda     shift to state 40
  On cond_block shift to state 41
  On def_stmt   shift to state 42
  On block      shift to state 43
  On tuple      shift to state 44
  On stmt       shift to state 45
  On true       shift to state 46

State 3
  primary    → literal •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 4
  member     → sum • "in" sum
  member     → sum •
  sum        → sum • "+" product
  sum        → sum • "-" product

  On {          reduce rule 14 (member)
  On NL         reduce rule 14 (member)
  On in         shift to state 48
  On cond       reduce rule 14 (member)
  On >          reduce rule 14 (member)
  On do         reduce rule 14 (member)
  On and        reduce rule 14 (member)
  On false      reduce rule 14 (member)
  On [          reduce rule 14 (member)
  On not        reduce rule 14 (member)
  On +          shift to state 49
  On nil        reduce rule 14 (member)
  On >=         reduce rule 14 (member)
  On NUM        reduce rule 14 (member)
  On or         reduce rule 14 (member)
  On -          shift to state 47
  On (          reduce rule 14 (member)
  On <          reduce rule 14 (member)
  On if         reduce rule 14 (member)
  On ,          reduce rule 14 (member)
  On ==         reduce rule 14 (member)
  On :          reduce rule 14 (member)
  On )          reduce rule 14 (member)
  On STR        reduce rule 14 (member)
  On ID         reduce rule 14 (member)
  On #[         reduce rule 14 (member)
  On <=         reduce rule 14 (member)
  On !=         reduce rule 14 (member)
  On ->         reduce rule 14 (member)
  On true       reduce rule 14 (member)

State 5
  map        → "{" • entries "}"
  entries    → • entries entry
  entries    → ε •

  On }          reduce rule 36 (entries)
  On ID         reduce rule 36 (entries)
  On entries    shift to state 50

State 6
  block      → do_block •

  On /          reduce rule 23 (block)
  On {          reduce rule 23 (block)
  On NL         reduce rule 23 (block)
  On in         reduce rule 23 (block)
  On cond       reduce rule 23 (block)
  On >          reduce rule 23 (block)
  On do         reduce rule 23 (block)
  On and        reduce rule 23 (block)
  On false      reduce rule 23 (block)
  On [          reduce rule 23 (block)
  On not        reduce rule 23 (block)
  On +          reduce rule 23 (block)
  On nil        reduce rule 23 (block)
  On >=         reduce rule 23 (block)
  On NUM        reduce rule 23 (block)
  On or         reduce rule 23 (block)
  On -          reduce rule 23 (block)
  On (          reduce rule 23 (block)
  On <          reduce rule 23 (block)
  On if         reduce rule 23 (block)
  On ,          reduce rule 23 (block)
  On ==         reduce rule 23 (block)
  On :          reduce rule 23 (block)
  On )          reduce rule 23 (block)
  On STR        reduce rule 23 (block)
  On ID         reduce rule 23 (block)
  On *          reduce rule 23 (block)
  On #[         reduce rule 23 (block)
  On <=         reduce rule 23 (block)
  On !=         reduce rule 23 (block)
  On ->         reduce rule 23 (block)
  On true       reduce rule 23 (block)

State 7
  lambda     → logic •
  logic      → logic • "and" equals
  logic      → logic • "or" equals

  On (          reduce rule 10 (lambda)
  On {          reduce rule 10 (lambda)
  On NL         reduce rule 10 (lambda)
  On if         reduce rule 10 (lambda)
  On ,          reduce rule 10 (lambda)
  On cond       reduce rule 10 (lambda)
  On :          reduce rule 10 (lambda)
  On do         reduce rule 10 (lambda)
  On )          reduce rule 10 (lambda)
  On STR        reduce rule 10 (lambda)
  On and        shift to state 51
  On false      reduce rule 10 (lambda)
  On ID         reduce rule 10 (lambda)
  On [          reduce rule 10 (lambda)
  On #[         reduce rule 10 (lambda)
  On not        reduce rule 10 (lambda)
  On nil        reduce rule 10 (lambda)
  On NUM        reduce rule 10 (lambda)
  On true       reduce rule 10 (lambda)
  On or         shift to state 52

State 8
  cond_block → "cond" • "do" clauses "end"

  On do         shift to state 53

State 9
  primary    → symbol •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 10
  do_block   → "do" • stmts "end"
  stmts      → • stmts stmt NL
  stmts      → • NL
  stmts      → ε •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On NL         shift to state 1
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On stmts      shift to state 54
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 11
  sum        → product •
  product    → product • "*" unary
  product    → product • "/" unary

  On /          shift to state 55
  On {          reduce rule 15 (sum)
  On NL         reduce rule 15 (sum)
  On in         reduce rule 15 (sum)
  On cond       reduce rule 15 (sum)
  On >          reduce rule 15 (sum)
  On do         reduce rule 15 (sum)
  On and        reduce rule 15 (sum)
  On false      reduce rule 15 (sum)
  On [          reduce rule 15 (sum)
  On not        reduce rule 15 (sum)
  On +          reduce rule 15 (sum)
  On nil        reduce rule 15 (sum)
  On >=         reduce rule 15 (sum)
  On NUM        reduce rule 15 (sum)
  On or         reduce rule 15 (sum)
  On -          reduce rule 15 (sum)
  On (          reduce rule 15 (sum)
  On <          reduce rule 15 (sum)
  On if         reduce rule 15 (sum)
  On ,          reduce rule 15 (sum)
  On ==         reduce rule 15 (sum)
  On :          reduce rule 15 (sum)
  On )          reduce rule 15 (sum)
  On STR        reduce rule 15 (sum)
  On ID         reduce rule 15 (sum)
  On *          shift to state 56
  On #[         reduce rule 15 (sum)
  On <=         reduce rule 15 (sum)
  On !=         reduce rule 15 (sum)
  On ->         reduce rule 15 (sum)
  On true       reduce rule 15 (sum)

State 12
  object     → map •

  On /          reduce rule 30 (object)
  On {          reduce rule 30 (object)
  On NL         reduce rule 30 (object)
  On in         reduce rule 30 (object)
  On cond       reduce rule 30 (object)
  On >          reduce rule 30 (object)
  On do         reduce rule 30 (object)
  On and        reduce rule 30 (object)
  On false      reduce rule 30 (object)
  On [          reduce rule 30 (object)
  On not        reduce rule 30 (object)
  On +          reduce rule 30 (object)
  On nil        reduce rule 30 (object)
  On >=         reduce rule 30 (object)
  On NUM        reduce rule 30 (object)
  On or         reduce rule 30 (object)
  On -          reduce rule 30 (object)
  On (          reduce rule 30 (object)
  On <          reduce rule 30 (object)
  On if         reduce rule 30 (object)
  On ,          reduce rule 30 (object)
  On ==         reduce rule 30 (object)
  On :          reduce rule 30 (object)
  On )          reduce rule 30 (object)
  On STR        reduce rule 30 (object)
  On ID         reduce rule 30 (object)
  On *          reduce rule 30 (object)
  On #[         reduce rule 30 (object)
  On <=         reduce rule 30 (object)
  On !=         reduce rule 30 (object)
  On ->         reduce rule 30 (object)
  On true       reduce rule 30 (object)

State 13
  stmt       → let_stmt •

  On NL         reduce rule 2 (stmt)

State 14
  literal    → "false" •

  On /          reduce rule 19 (literal)
  On {          reduce rule 19 (literal)
  On NL         reduce rule 19 (literal)
  On in         reduce rule 19 (literal)
  On cond       reduce rule 19 (literal)
  On >          reduce rule 19 (literal)
  On do         reduce rule 19 (literal)
  On and        reduce rule 19 (literal)
  On false      reduce rule 19 (literal)
  On [          reduce rule 19 (literal)
  On not        reduce rule 19 (literal)
  On +          reduce rule 19 (literal)
  On nil        reduce rule 19 (literal)
  On >=         reduce rule 19 (literal)
  On NUM        reduce rule 19 (literal)
  On or         reduce rule 19 (literal)
  On -          reduce rule 19 (literal)
  On (          reduce rule 19 (literal)
  On <          reduce rule 19 (literal)
  On if         reduce rule 19 (literal)
  On ,          reduce rule 19 (literal)
  On ==         reduce rule 19 (literal)
  On :          reduce rule 19 (literal)
  On )          reduce rule 19 (literal)
  On STR        reduce rule 19 (literal)
  On ID         reduce rule 19 (literal)
  On *          reduce rule 19 (literal)
  On #[         reduce rule 19 (literal)
  On <=         reduce rule 19 (literal)
  On !=         reduce rule 19 (literal)
  On ->         reduce rule 19 (literal)
  On true       reduce rule 19 (literal)

State 15
  logic      → equals •

  On (          reduce rule 11 (logic)
  On {          reduce rule 11 (logic)
  On NL         reduce rule 11 (logic)
  On if         reduce rule 11 (logic)
  On ,          reduce rule 11 (logic)
  On cond       reduce rule 11 (logic)
  On :          reduce rule 11 (logic)
  On do         reduce rule 11 (logic)
  On )          reduce rule 11 (logic)
  On STR        reduce rule 11 (logic)
  On and        reduce rule 11 (logic)
  On false      reduce rule 11 (logic)
  On ID         reduce rule 11 (logic)
  On [          reduce rule 11 (logic)
  On #[         reduce rule 11 (logic)
  On not        reduce rule 11 (logic)
  On nil        reduce rule 11 (logic)
  On NUM        reduce rule 11 (logic)
  On ->         reduce rule 11 (logic)
  On true       reduce rule 11 (logic)
  On or         reduce rule 11 (logic)

State 16
  list       → "[" • items "]"
  items      → • items item
  items      → ε •

  On ]          reduce rule 34 (items)
  On (          reduce rule 34 (items)
  On {          reduce rule 34 (items)
  On if         reduce rule 34 (items)
  On cond       reduce rule 34 (items)
  On :          reduce rule 34 (items)
  On do         reduce rule 34 (items)
  On STR        reduce rule 34 (items)
  On false      reduce rule 34 (items)
  On ID         reduce rule 34 (items)
  On [          reduce rule 34 (items)
  On #[         reduce rule 34 (items)
  On not        reduce rule 34 (items)
  On nil        reduce rule 34 (items)
  On NUM        reduce rule 34 (items)
  On items      shift to state 57
  On true       reduce rule 34 (items)

State 17
  def_stmt   → "def" • "(" id_list ")" arg

  On (          shift to state 58

State 18
  unary      → "not" • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 60
  On ID         shift to state 35
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 19
  stmt       → call •
  call       → call • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On NL         reduce rule 2 (stmt)
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 61
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 20
  block      → if_block •

  On /          reduce rule 23 (block)
  On {          reduce rule 23 (block)
  On NL         reduce rule 23 (block)
  On in         reduce rule 23 (block)
  On cond       reduce rule 23 (block)
  On >          reduce rule 23 (block)
  On do         reduce rule 23 (block)
  On and        reduce rule 23 (block)
  On false      reduce rule 23 (block)
  On [          reduce rule 23 (block)
  On not        reduce rule 23 (block)
  On +          reduce rule 23 (block)
  On nil        reduce rule 23 (block)
  On >=         reduce rule 23 (block)
  On NUM        reduce rule 23 (block)
  On or         reduce rule 23 (block)
  On -          reduce rule 23 (block)
  On (          reduce rule 23 (block)
  On <          reduce rule 23 (block)
  On if         reduce rule 23 (block)
  On ,          reduce rule 23 (block)
  On ==         reduce rule 23 (block)
  On :          reduce rule 23 (block)
  On )          reduce rule 23 (block)
  On STR        reduce rule 23 (block)
  On ID         reduce rule 23 (block)
  On *          reduce rule 23 (block)
  On #[         reduce rule 23 (block)
  On <=         reduce rule 23 (block)
  On !=         reduce rule 23 (block)
  On ->         reduce rule 23 (block)
  On true       reduce rule 23 (block)

State 21
  let_stmt   → "let" • assigns
  assigns    → • assigns "," assign
  assigns    → • assign
  assign     → • ID "=" call

  On assign     shift to state 62
  On ID         shift to state 63
  On assigns    shift to state 64

State 22
  literal    → "nil" •

  On /          reduce rule 19 (literal)
  On {          reduce rule 19 (literal)
  On NL         reduce rule 19 (literal)
  On in         reduce rule 19 (literal)
  On cond       reduce rule 19 (literal)
  On >          reduce rule 19 (literal)
  On do         reduce rule 19 (literal)
  On and        reduce rule 19 (literal)
  On false      reduce rule 19 (literal)
  On [          reduce rule 19 (literal)
  On not        reduce rule 19 (literal)
  On +          reduce rule 19 (literal)
  On nil        reduce rule 19 (literal)
  On >=         reduce rule 19 (literal)
  On NUM        reduce rule 19 (literal)
  On or         reduce rule 19 (literal)
  On -          reduce rule 19 (literal)
  On (          reduce rule 19 (literal)
  On <          reduce rule 19 (literal)
  On if         reduce rule 19 (literal)
  On ,          reduce rule 19 (literal)
  On ==         reduce rule 19 (literal)
  On :          reduce rule 19 (literal)
  On )          reduce rule 19 (literal)
  On STR        reduce rule 19 (literal)
  On ID         reduce rule 19 (literal)
  On *          reduce rule 19 (literal)
  On #[         reduce rule 19 (literal)
  On <=         reduce rule 19 (literal)
  On !=         reduce rule 19 (literal)
  On ->         reduce rule 19 (literal)
  On true       reduce rule 19 (literal)

State 23
  primary    → access •
  access     → access • "." ID

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On .          shift to state 65
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 24
  primary    → NUM •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 25
  product    → unary •

  On /          reduce rule 16 (product)
  On {          reduce rule 16 (product)
  On NL         reduce rule 16 (product)
  On in         reduce rule 16 (product)
  On cond       reduce rule 16 (product)
  On >          reduce rule 16 (product)
  On do         reduce rule 16 (product)
  On and        reduce rule 16 (product)
  On false      reduce rule 16 (product)
  On [          reduce rule 16 (product)
  On not        reduce rule 16 (product)
  On +          reduce rule 16 (product)
  On nil        reduce rule 16 (product)
  On >=         reduce rule 16 (product)
  On NUM        reduce rule 16 (product)
  On or         reduce rule 16 (product)
  On -          reduce rule 16 (product)
  On (          reduce rule 16 (product)
  On <          reduce rule 16 (product)
  On if         reduce rule 16 (product)
  On ,          reduce rule 16 (product)
  On ==         reduce rule 16 (product)
  On :          reduce rule 16 (product)
  On )          reduce rule 16 (product)
  On STR        reduce rule 16 (product)
  On ID         reduce rule 16 (product)
  On *          reduce rule 16 (product)
  On #[         reduce rule 16 (product)
  On <=         reduce rule 16 (product)
  On !=         reduce rule 16 (product)
  On ->         reduce rule 16 (product)
  On true       reduce rule 16 (product)

State 26
  equals     → compare • "==" compare
  equals     → compare • "!=" compare
  equals     → compare •

  On (          reduce rule 12 (equals)
  On {          reduce rule 12 (equals)
  On NL         reduce rule 12 (equals)
  On if         reduce rule 12 (equals)
  On ,          reduce rule 12 (equals)
  On cond       reduce rule 12 (equals)
  On ==         shift to state 66
  On :          reduce rule 12 (equals)
  On do         reduce rule 12 (equals)
  On )          reduce rule 12 (equals)
  On STR        reduce rule 12 (equals)
  On and        reduce rule 12 (equals)
  On false      reduce rule 12 (equals)
  On ID         reduce rule 12 (equals)
  On [          reduce rule 12 (equals)
  On #[         reduce rule 12 (equals)
  On not        reduce rule 12 (equals)
  On nil        reduce rule 12 (equals)
  On !=         shift to state 67
  On NUM        reduce rule 12 (equals)
  On ->         reduce rule 12 (equals)
  On true       reduce rule 12 (equals)
  On or         reduce rule 12 (equals)

State 27
  primary    → object •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 28
  group      → "(" • call ")"
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On call       shift to state 68
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 29
  call       → arg •

  On (          reduce rule 8 (call)
  On {          reduce rule 8 (call)
  On NL         reduce rule 8 (call)
  On if         reduce rule 8 (call)
  On ,          reduce rule 8 (call)
  On cond       reduce rule 8 (call)
  On :          reduce rule 8 (call)
  On do         reduce rule 8 (call)
  On )          reduce rule 8 (call)
  On STR        reduce rule 8 (call)
  On false      reduce rule 8 (call)
  On ID         reduce rule 8 (call)
  On [          reduce rule 8 (call)
  On #[         reduce rule 8 (call)
  On not        reduce rule 8 (call)
  On nil        reduce rule 8 (call)
  On NUM        reduce rule 8 (call)
  On true       reduce rule 8 (call)

State 30
  if_block   → "if" • arg do_else
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 69
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 31
  symbol     → ":" • ID

  On ID         shift to state 70

State 32
  lambda     → group • "->" lambda
  primary    → group •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         shift to state 71
  On true       reduce rule 18 (primary)

State 33
  primary    → STR •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 34
  unary      → primary •

  On /          reduce rule 17 (unary)
  On {          reduce rule 17 (unary)
  On NL         reduce rule 17 (unary)
  On in         reduce rule 17 (unary)
  On cond       reduce rule 17 (unary)
  On >          reduce rule 17 (unary)
  On do         reduce rule 17 (unary)
  On and        reduce rule 17 (unary)
  On false      reduce rule 17 (unary)
  On [          reduce rule 17 (unary)
  On not        reduce rule 17 (unary)
  On +          reduce rule 17 (unary)
  On nil        reduce rule 17 (unary)
  On >=         reduce rule 17 (unary)
  On NUM        reduce rule 17 (unary)
  On or         reduce rule 17 (unary)
  On -          reduce rule 17 (unary)
  On (          reduce rule 17 (unary)
  On <          reduce rule 17 (unary)
  On if         reduce rule 17 (unary)
  On ,          reduce rule 17 (unary)
  On ==         reduce rule 17 (unary)
  On :          reduce rule 17 (unary)
  On )          reduce rule 17 (unary)
  On STR        reduce rule 17 (unary)
  On ID         reduce rule 17 (unary)
  On *          reduce rule 17 (unary)
  On #[         reduce rule 17 (unary)
  On <=         reduce rule 17 (unary)
  On !=         reduce rule 17 (unary)
  On ->         reduce rule 17 (unary)
  On true       reduce rule 17 (unary)

State 35
  primary    → ID •
  access     → ID • "." ID

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On .          shift to state 72
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 36
  compare    → member • ">" member
  compare    → member • ">=" member
  compare    → member • "<" member
  compare    → member • "<=" member
  compare    → member •

  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On >          shift to state 74
  On do         reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On >=         shift to state 76
  On NUM        reduce rule 13 (compare)
  On or         reduce rule 13 (compare)
  On (          reduce rule 13 (compare)
  On <          shift to state 73
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On <=         shift to state 75
  On !=         reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)

State 37
  tuple      → "#[" • items "]"
  items      → • items item
  items      → ε •

  On ]          reduce rule 34 (items)
  On (          reduce rule 34 (items)
  On {          reduce rule 34 (items)
  On if         reduce rule 34 (items)
  On cond       reduce rule 34 (items)
  On :          reduce rule 34 (items)
  On do         reduce rule 34 (items)
  On STR        reduce rule 34 (items)
  On false      reduce rule 34 (items)
  On ID         reduce rule 34 (items)
  On [          reduce rule 34 (items)
  On #[         reduce rule 34 (items)
  On not        reduce rule 34 (items)
  On nil        reduce rule 34 (items)
  On NUM        reduce rule 34 (items)
  On items      shift to state 77
  On true       reduce rule 34 (items)

State 38
  object     → list •

  On /          reduce rule 30 (object)
  On {          reduce rule 30 (object)
  On NL         reduce rule 30 (object)
  On in         reduce rule 30 (object)
  On cond       reduce rule 30 (object)
  On >          reduce rule 30 (object)
  On do         reduce rule 30 (object)
  On and        reduce rule 30 (object)
  On false      reduce rule 30 (object)
  On [          reduce rule 30 (object)
  On not        reduce rule 30 (object)
  On +          reduce rule 30 (object)
  On nil        reduce rule 30 (object)
  On >=         reduce rule 30 (object)
  On NUM        reduce rule 30 (object)
  On or         reduce rule 30 (object)
  On -          reduce rule 30 (object)
  On (          reduce rule 30 (object)
  On <          reduce rule 30 (object)
  On if         reduce rule 30 (object)
  On ,          reduce rule 30 (object)
  On ==         reduce rule 30 (object)
  On :          reduce rule 30 (object)
  On )          reduce rule 30 (object)
  On STR        reduce rule 30 (object)
  On ID         reduce rule 30 (object)
  On *          reduce rule 30 (object)
  On #[         reduce rule 30 (object)
  On <=         reduce rule 30 (object)
  On !=         reduce rule 30 (object)
  On ->         reduce rule 30 (object)
  On true       reduce rule 30 (object)

State 39
  program    → stmts $ •

State 40
  arg        → lambda •

  On (          reduce rule 9 (arg)
  On {          reduce rule 9 (arg)
  On NL         reduce rule 9 (arg)
  On if         reduce rule 9 (arg)
  On ,          reduce rule 9 (arg)
  On cond       reduce rule 9 (arg)
  On :          reduce rule 9 (arg)
  On do         reduce rule 9 (arg)
  On )          reduce rule 9 (arg)
  On STR        reduce rule 9 (arg)
  On false      reduce rule 9 (arg)
  On ID         reduce rule 9 (arg)
  On [          reduce rule 9 (arg)
  On #[         reduce rule 9 (arg)
  On not        reduce rule 9 (arg)
  On nil        reduce rule 9 (arg)
  On NUM        reduce rule 9 (arg)
  On true       reduce rule 9 (arg)

State 41
  block      → cond_block •

  On /          reduce rule 23 (block)
  On {          reduce rule 23 (block)
  On NL         reduce rule 23 (block)
  On in         reduce rule 23 (block)
  On cond       reduce rule 23 (block)
  On >          reduce rule 23 (block)
  On do         reduce rule 23 (block)
  On and        reduce rule 23 (block)
  On false      reduce rule 23 (block)
  On [          reduce rule 23 (block)
  On not        reduce rule 23 (block)
  On +          reduce rule 23 (block)
  On nil        reduce rule 23 (block)
  On >=         reduce rule 23 (block)
  On NUM        reduce rule 23 (block)
  On or         reduce rule 23 (block)
  On -          reduce rule 23 (block)
  On (          reduce rule 23 (block)
  On <          reduce rule 23 (block)
  On if         reduce rule 23 (block)
  On ,          reduce rule 23 (block)
  On ==         reduce rule 23 (block)
  On :          reduce rule 23 (block)
  On )          reduce rule 23 (block)
  On STR        reduce rule 23 (block)
  On ID         reduce rule 23 (block)
  On *          reduce rule 23 (block)
  On #[         reduce rule 23 (block)
  On <=         reduce rule 23 (block)
  On !=         reduce rule 23 (block)
  On ->         reduce rule 23 (block)
  On true       reduce rule 23 (block)

State 42
  stmt       → def_stmt •

  On NL         reduce rule 2 (stmt)

State 43
  primary    → block •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 44
  object     → tuple •

  On /          reduce rule 30 (object)
  On {          reduce rule 30 (object)
  On NL         reduce rule 30 (object)
  On in         reduce rule 30 (object)
  On cond       reduce rule 30 (object)
  On >          reduce rule 30 (object)
  On do         reduce rule 30 (object)
  On and        reduce rule 30 (object)
  On false      reduce rule 30 (object)
  On [          reduce rule 30 (object)
  On not        reduce rule 30 (object)
  On +          reduce rule 30 (object)
  On nil        reduce rule 30 (object)
  On >=         reduce rule 30 (object)
  On NUM        reduce rule 30 (object)
  On or         reduce rule 30 (object)
  On -          reduce rule 30 (object)
  On (          reduce rule 30 (object)
  On <          reduce rule 30 (object)
  On if         reduce rule 30 (object)
  On ,          reduce rule 30 (object)
  On ==         reduce rule 30 (object)
  On :          reduce rule 30 (object)
  On )          reduce rule 30 (object)
  On STR        reduce rule 30 (object)
  On ID         reduce rule 30 (object)
  On *          reduce rule 30 (object)
  On #[         reduce rule 30 (object)
  On <=         reduce rule 30 (object)
  On !=         reduce rule 30 (object)
  On ->         reduce rule 30 (object)
  On true       reduce rule 30 (object)

State 45
  stmts      → stmts stmt • NL

  On NL         shift to state 78

State 46
  literal    → "true" •

  On /          reduce rule 19 (literal)
  On {          reduce rule 19 (literal)
  On NL         reduce rule 19 (literal)
  On in         reduce rule 19 (literal)
  On cond       reduce rule 19 (literal)
  On >          reduce rule 19 (literal)
  On do         reduce rule 19 (literal)
  On and        reduce rule 19 (literal)
  On false      reduce rule 19 (literal)
  On [          reduce rule 19 (literal)
  On not        reduce rule 19 (literal)
  On +          reduce rule 19 (literal)
  On nil        reduce rule 19 (literal)
  On >=         reduce rule 19 (literal)
  On NUM        reduce rule 19 (literal)
  On or         reduce rule 19 (literal)
  On -          reduce rule 19 (literal)
  On (          reduce rule 19 (literal)
  On <          reduce rule 19 (literal)
  On if         reduce rule 19 (literal)
  On ,          reduce rule 19 (literal)
  On ==         reduce rule 19 (literal)
  On :          reduce rule 19 (literal)
  On )          reduce rule 19 (literal)
  On STR        reduce rule 19 (literal)
  On ID         reduce rule 19 (literal)
  On *          reduce rule 19 (literal)
  On #[         reduce rule 19 (literal)
  On <=         reduce rule 19 (literal)
  On !=         reduce rule 19 (literal)
  On ->         reduce rule 19 (literal)
  On true       reduce rule 19 (literal)

State 47
  sum        → sum "-" • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 79
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 48
  member     → sum "in" • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 80
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 49
  sum        → sum "+" • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 81
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 50
  map        → "{" entries • "}"
  entries    → entries • entry
  entry      → • ID ":" arg opt_comma

  On entry      shift to state 82
  On }          shift to state 83
  On ID         shift to state 84

State 51
  logic      → logic "and" • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 85
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 52
  logic      → logic "or" • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 86
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 53
  cond_block → "cond" "do" • clauses "end"
  clauses    → • clauses clause
  clauses    → • NL
  clauses    → ε •

  On clauses    shift to state 87
  On (          reduce rule 28 (clauses)
  On {          reduce rule 28 (clauses)
  On NL         shift to state 88
  On if         reduce rule 28 (clauses)
  On cond       reduce rule 28 (clauses)
  On :          reduce rule 28 (clauses)
  On do         reduce rule 28 (clauses)
  On STR        reduce rule 28 (clauses)
  On false      reduce rule 28 (clauses)
  On ID         reduce rule 28 (clauses)
  On [          reduce rule 28 (clauses)
  On #[         reduce rule 28 (clauses)
  On not        reduce rule 28 (clauses)
  On end        reduce rule 28 (clauses)
  On nil        reduce rule 28 (clauses)
  On NUM        reduce rule 28 (clauses)
  On true       reduce rule 28 (clauses)

State 54
  do_block   → "do" stmts • "end"
  stmts      → stmts • stmt NL
  stmt       → • let_stmt
  stmt       → • def_stmt
  stmt       → • call
  let_stmt   → • "let" assigns
  def_stmt   → • "def" "(" id_list ")" arg
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On literal    shift to state 3
  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On let_stmt   shift to state 13
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On def        shift to state 17
  On not        shift to state 18
  On end        shift to state 89
  On call       shift to state 19
  On if_block   shift to state 20
  On let        shift to state 21
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On def_stmt   shift to state 42
  On block      shift to state 43
  On tuple      shift to state 44
  On stmt       shift to state 45
  On true       shift to state 46

State 55
  product    → product "/" • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 90
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 56
  product    → product "*" • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 91
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 57
  list       → "[" items • "]"
  items      → items • item
  item       → • arg opt_comma
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On ]          shift to state 92
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 93
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On item       shift to state 94
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 58
  def_stmt   → "def" "(" • id_list ")" arg
  id_list    → • id_list ID
  id_list    → • ID

  On id_list    shift to state 95
  On ID         shift to state 96

State 59
  primary    → group •

  On /          reduce rule 18 (primary)
  On {          reduce rule 18 (primary)
  On NL         reduce rule 18 (primary)
  On in         reduce rule 18 (primary)
  On cond       reduce rule 18 (primary)
  On >          reduce rule 18 (primary)
  On do         reduce rule 18 (primary)
  On and        reduce rule 18 (primary)
  On false      reduce rule 18 (primary)
  On [          reduce rule 18 (primary)
  On not        reduce rule 18 (primary)
  On +          reduce rule 18 (primary)
  On nil        reduce rule 18 (primary)
  On >=         reduce rule 18 (primary)
  On NUM        reduce rule 18 (primary)
  On or         reduce rule 18 (primary)
  On -          reduce rule 18 (primary)
  On (          reduce rule 18 (primary)
  On <          reduce rule 18 (primary)
  On if         reduce rule 18 (primary)
  On ,          reduce rule 18 (primary)
  On ==         reduce rule 18 (primary)
  On :          reduce rule 18 (primary)
  On )          reduce rule 18 (primary)
  On STR        reduce rule 18 (primary)
  On ID         reduce rule 18 (primary)
  On *          reduce rule 18 (primary)
  On #[         reduce rule 18 (primary)
  On <=         reduce rule 18 (primary)
  On !=         reduce rule 18 (primary)
  On ->         reduce rule 18 (primary)
  On true       reduce rule 18 (primary)

State 60
  unary      → "not" primary •

  On /          reduce rule 17 (unary)
  On {          reduce rule 17 (unary)
  On NL         reduce rule 17 (unary)
  On in         reduce rule 17 (unary)
  On cond       reduce rule 17 (unary)
  On >          reduce rule 17 (unary)
  On do         reduce rule 17 (unary)
  On and        reduce rule 17 (unary)
  On false      reduce rule 17 (unary)
  On [          reduce rule 17 (unary)
  On not        reduce rule 17 (unary)
  On +          reduce rule 17 (unary)
  On nil        reduce rule 17 (unary)
  On >=         reduce rule 17 (unary)
  On NUM        reduce rule 17 (unary)
  On or         reduce rule 17 (unary)
  On -          reduce rule 17 (unary)
  On (          reduce rule 17 (unary)
  On <          reduce rule 17 (unary)
  On if         reduce rule 17 (unary)
  On ,          reduce rule 17 (unary)
  On ==         reduce rule 17 (unary)
  On :          reduce rule 17 (unary)
  On )          reduce rule 17 (unary)
  On STR        reduce rule 17 (unary)
  On ID         reduce rule 17 (unary)
  On *          reduce rule 17 (unary)
  On #[         reduce rule 17 (unary)
  On <=         reduce rule 17 (unary)
  On !=         reduce rule 17 (unary)
  On ->         reduce rule 17 (unary)
  On true       reduce rule 17 (unary)

State 61
  call       → call arg •

  On (          reduce rule 8 (call)
  On {          reduce rule 8 (call)
  On NL         reduce rule 8 (call)
  On if         reduce rule 8 (call)
  On ,          reduce rule 8 (call)
  On cond       reduce rule 8 (call)
  On :          reduce rule 8 (call)
  On do         reduce rule 8 (call)
  On )          reduce rule 8 (call)
  On STR        reduce rule 8 (call)
  On false      reduce rule 8 (call)
  On ID         reduce rule 8 (call)
  On [          reduce rule 8 (call)
  On #[         reduce rule 8 (call)
  On not        reduce rule 8 (call)
  On nil        reduce rule 8 (call)
  On NUM        reduce rule 8 (call)
  On true       reduce rule 8 (call)

State 62
  assigns    → assign •

  On NL         reduce rule 4 (assigns)
  On ,          reduce rule 4 (assigns)

State 63
  assign     → ID • "=" call

  On =          shift to state 97

State 64
  let_stmt   → "let" assigns •
  assigns    → assigns • "," assign

  On NL         reduce rule 3 (let_stmt)
  On ,          shift to state 98

State 65
  access     → access "." • ID

  On ID         shift to state 99

State 66
  equals     → compare "==" • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 100
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 67
  equals     → compare "!=" • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 101
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 68
  group      → "(" call • ")"
  call       → call • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 61
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On )          shift to state 102
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 69
  if_block   → "if" arg • do_else
  do_else    → • "do" stmts "else" stmts "end"

  On do_else    shift to state 103
  On do         shift to state 104

State 70
  symbol     → ":" ID •

  On /          reduce rule 20 (symbol)
  On {          reduce rule 20 (symbol)
  On NL         reduce rule 20 (symbol)
  On in         reduce rule 20 (symbol)
  On cond       reduce rule 20 (symbol)
  On >          reduce rule 20 (symbol)
  On do         reduce rule 20 (symbol)
  On and        reduce rule 20 (symbol)
  On false      reduce rule 20 (symbol)
  On [          reduce rule 20 (symbol)
  On not        reduce rule 20 (symbol)
  On +          reduce rule 20 (symbol)
  On nil        reduce rule 20 (symbol)
  On >=         reduce rule 20 (symbol)
  On NUM        reduce rule 20 (symbol)
  On or         reduce rule 20 (symbol)
  On -          reduce rule 20 (symbol)
  On (          reduce rule 20 (symbol)
  On <          reduce rule 20 (symbol)
  On if         reduce rule 20 (symbol)
  On ,          reduce rule 20 (symbol)
  On ==         reduce rule 20 (symbol)
  On :          reduce rule 20 (symbol)
  On )          reduce rule 20 (symbol)
  On STR        reduce rule 20 (symbol)
  On ID         reduce rule 20 (symbol)
  On *          reduce rule 20 (symbol)
  On #[         reduce rule 20 (symbol)
  On <=         reduce rule 20 (symbol)
  On !=         reduce rule 20 (symbol)
  On ->         reduce rule 20 (symbol)
  On true       reduce rule 20 (symbol)

State 71
  lambda     → group "->" • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 105
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 72
  access     → ID "." • ID

  On ID         shift to state 106

State 73
  compare    → member "<" • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 107
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 74
  compare    → member ">" • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 108
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 75
  compare    → member "<=" • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 109
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 76
  compare    → member ">=" • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 110
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 77
  tuple      → "#[" items • "]"
  items      → items • item
  item       → • arg opt_comma
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On ]          shift to state 111
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 93
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On item       shift to state 94
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 78
  stmts      → stmts stmt NL •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 79
  sum        → sum "-" product •
  product    → product • "*" unary
  product    → product • "/" unary

  On /          shift to state 55
  On {          reduce rule 15 (sum)
  On NL         reduce rule 15 (sum)
  On in         reduce rule 15 (sum)
  On cond       reduce rule 15 (sum)
  On >          reduce rule 15 (sum)
  On do         reduce rule 15 (sum)
  On and        reduce rule 15 (sum)
  On false      reduce rule 15 (sum)
  On [          reduce rule 15 (sum)
  On not        reduce rule 15 (sum)
  On +          reduce rule 15 (sum)
  On nil        reduce rule 15 (sum)
  On >=         reduce rule 15 (sum)
  On NUM        reduce rule 15 (sum)
  On or         reduce rule 15 (sum)
  On -          reduce rule 15 (sum)
  On (          reduce rule 15 (sum)
  On <          reduce rule 15 (sum)
  On if         reduce rule 15 (sum)
  On ,          reduce rule 15 (sum)
  On ==         reduce rule 15 (sum)
  On :          reduce rule 15 (sum)
  On )          reduce rule 15 (sum)
  On STR        reduce rule 15 (sum)
  On ID         reduce rule 15 (sum)
  On *          shift to state 56
  On #[         reduce rule 15 (sum)
  On <=         reduce rule 15 (sum)
  On !=         reduce rule 15 (sum)
  On ->         reduce rule 15 (sum)
  On true       reduce rule 15 (sum)

State 80
  member     → sum "in" sum •
  sum        → sum • "+" product
  sum        → sum • "-" product

  On {          reduce rule 14 (member)
  On NL         reduce rule 14 (member)
  On cond       reduce rule 14 (member)
  On >          reduce rule 14 (member)
  On do         reduce rule 14 (member)
  On and        reduce rule 14 (member)
  On false      reduce rule 14 (member)
  On [          reduce rule 14 (member)
  On not        reduce rule 14 (member)
  On +          shift to state 49
  On nil        reduce rule 14 (member)
  On >=         reduce rule 14 (member)
  On NUM        reduce rule 14 (member)
  On or         reduce rule 14 (member)
  On -          shift to state 47
  On (          reduce rule 14 (member)
  On <          reduce rule 14 (member)
  On if         reduce rule 14 (member)
  On ,          reduce rule 14 (member)
  On ==         reduce rule 14 (member)
  On :          reduce rule 14 (member)
  On )          reduce rule 14 (member)
  On STR        reduce rule 14 (member)
  On ID         reduce rule 14 (member)
  On #[         reduce rule 14 (member)
  On <=         reduce rule 14 (member)
  On !=         reduce rule 14 (member)
  On ->         reduce rule 14 (member)
  On true       reduce rule 14 (member)

State 81
  sum        → sum "+" product •
  product    → product • "*" unary
  product    → product • "/" unary

  On /          shift to state 55
  On {          reduce rule 15 (sum)
  On NL         reduce rule 15 (sum)
  On in         reduce rule 15 (sum)
  On cond       reduce rule 15 (sum)
  On >          reduce rule 15 (sum)
  On do         reduce rule 15 (sum)
  On and        reduce rule 15 (sum)
  On false      reduce rule 15 (sum)
  On [          reduce rule 15 (sum)
  On not        reduce rule 15 (sum)
  On +          reduce rule 15 (sum)
  On nil        reduce rule 15 (sum)
  On >=         reduce rule 15 (sum)
  On NUM        reduce rule 15 (sum)
  On or         reduce rule 15 (sum)
  On -          reduce rule 15 (sum)
  On (          reduce rule 15 (sum)
  On <          reduce rule 15 (sum)
  On if         reduce rule 15 (sum)
  On ,          reduce rule 15 (sum)
  On ==         reduce rule 15 (sum)
  On :          reduce rule 15 (sum)
  On )          reduce rule 15 (sum)
  On STR        reduce rule 15 (sum)
  On ID         reduce rule 15 (sum)
  On *          shift to state 56
  On #[         reduce rule 15 (sum)
  On <=         reduce rule 15 (sum)
  On !=         reduce rule 15 (sum)
  On ->         reduce rule 15 (sum)
  On true       reduce rule 15 (sum)

State 82
  entries    → entries entry •

  On }          reduce rule 36 (entries)
  On ID         reduce rule 36 (entries)

State 83
  map        → "{" entries "}" •

  On /          reduce rule 33 (map)
  On {          reduce rule 33 (map)
  On NL         reduce rule 33 (map)
  On in         reduce rule 33 (map)
  On cond       reduce rule 33 (map)
  On >          reduce rule 33 (map)
  On do         reduce rule 33 (map)
  On and        reduce rule 33 (map)
  On false      reduce rule 33 (map)
  On [          reduce rule 33 (map)
  On not        reduce rule 33 (map)
  On +          reduce rule 33 (map)
  On nil        reduce rule 33 (map)
  On >=         reduce rule 33 (map)
  On NUM        reduce rule 33 (map)
  On or         reduce rule 33 (map)
  On -          reduce rule 33 (map)
  On (          reduce rule 33 (map)
  On <          reduce rule 33 (map)
  On if         reduce rule 33 (map)
  On ,          reduce rule 33 (map)
  On ==         reduce rule 33 (map)
  On :          reduce rule 33 (map)
  On )          reduce rule 33 (map)
  On STR        reduce rule 33 (map)
  On ID         reduce rule 33 (map)
  On *          reduce rule 33 (map)
  On #[         reduce rule 33 (map)
  On <=         reduce rule 33 (map)
  On !=         reduce rule 33 (map)
  On ->         reduce rule 33 (map)
  On true       reduce rule 33 (map)

State 84
  entry      → ID • ":" arg opt_comma

  On :          shift to state 112

State 85
  logic      → logic "and" equals •

  On (          reduce rule 11 (logic)
  On {          reduce rule 11 (logic)
  On NL         reduce rule 11 (logic)
  On if         reduce rule 11 (logic)
  On ,          reduce rule 11 (logic)
  On cond       reduce rule 11 (logic)
  On :          reduce rule 11 (logic)
  On do         reduce rule 11 (logic)
  On )          reduce rule 11 (logic)
  On STR        reduce rule 11 (logic)
  On and        reduce rule 11 (logic)
  On false      reduce rule 11 (logic)
  On ID         reduce rule 11 (logic)
  On [          reduce rule 11 (logic)
  On #[         reduce rule 11 (logic)
  On not        reduce rule 11 (logic)
  On nil        reduce rule 11 (logic)
  On NUM        reduce rule 11 (logic)
  On ->         reduce rule 11 (logic)
  On true       reduce rule 11 (logic)
  On or         reduce rule 11 (logic)

State 86
  logic      → logic "or" equals •

  On (          reduce rule 11 (logic)
  On {          reduce rule 11 (logic)
  On NL         reduce rule 11 (logic)
  On if         reduce rule 11 (logic)
  On ,          reduce rule 11 (logic)
  On cond       reduce rule 11 (logic)
  On :          reduce rule 11 (logic)
  On do         reduce rule 11 (logic)
  On )          reduce rule 11 (logic)
  On STR        reduce rule 11 (logic)
  On and        reduce rule 11 (logic)
  On false      reduce rule 11 (logic)
  On ID         reduce rule 11 (logic)
  On [          reduce rule 11 (logic)
  On #[         reduce rule 11 (logic)
  On not        reduce rule 11 (logic)
  On nil        reduce rule 11 (logic)
  On NUM        reduce rule 11 (logic)
  On ->         reduce rule 11 (logic)
  On true       reduce rule 11 (logic)
  On or         reduce rule 11 (logic)

State 87
  cond_block → "cond" "do" clauses • "end"
  clauses    → clauses • clause
  clause     → • logic "->" call NL
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  group      → • "(" call ")"
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 113
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On clause     shift to state 114
  On not        shift to state 18
  On end        shift to state 115
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 59
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 88
  clauses    → NL •

  On (          reduce rule 28 (clauses)
  On {          reduce rule 28 (clauses)
  On if         reduce rule 28 (clauses)
  On cond       reduce rule 28 (clauses)
  On :          reduce rule 28 (clauses)
  On do         reduce rule 28 (clauses)
  On STR        reduce rule 28 (clauses)
  On false      reduce rule 28 (clauses)
  On ID         reduce rule 28 (clauses)
  On [          reduce rule 28 (clauses)
  On #[         reduce rule 28 (clauses)
  On not        reduce rule 28 (clauses)
  On end        reduce rule 28 (clauses)
  On nil        reduce rule 28 (clauses)
  On NUM        reduce rule 28 (clauses)
  On true       reduce rule 28 (clauses)

State 89
  do_block   → "do" stmts "end" •

  On /          reduce rule 24 (do_block)
  On {          reduce rule 24 (do_block)
  On NL         reduce rule 24 (do_block)
  On in         reduce rule 24 (do_block)
  On cond       reduce rule 24 (do_block)
  On >          reduce rule 24 (do_block)
  On do         reduce rule 24 (do_block)
  On and        reduce rule 24 (do_block)
  On false      reduce rule 24 (do_block)
  On [          reduce rule 24 (do_block)
  On not        reduce rule 24 (do_block)
  On +          reduce rule 24 (do_block)
  On nil        reduce rule 24 (do_block)
  On >=         reduce rule 24 (do_block)
  On NUM        reduce rule 24 (do_block)
  On or         reduce rule 24 (do_block)
  On -          reduce rule 24 (do_block)
  On (          reduce rule 24 (do_block)
  On <          reduce rule 24 (do_block)
  On if         reduce rule 24 (do_block)
  On ,          reduce rule 24 (do_block)
  On ==         reduce rule 24 (do_block)
  On :          reduce rule 24 (do_block)
  On )          reduce rule 24 (do_block)
  On STR        reduce rule 24 (do_block)
  On ID         reduce rule 24 (do_block)
  On *          reduce rule 24 (do_block)
  On #[         reduce rule 24 (do_block)
  On <=         reduce rule 24 (do_block)
  On !=         reduce rule 24 (do_block)
  On ->         reduce rule 24 (do_block)
  On true       reduce rule 24 (do_block)

State 90
  product    → product "/" unary •

  On /          reduce rule 16 (product)
  On {          reduce rule 16 (product)
  On NL         reduce rule 16 (product)
  On in         reduce rule 16 (product)
  On cond       reduce rule 16 (product)
  On >          reduce rule 16 (product)
  On do         reduce rule 16 (product)
  On and        reduce rule 16 (product)
  On false      reduce rule 16 (product)
  On [          reduce rule 16 (product)
  On not        reduce rule 16 (product)
  On +          reduce rule 16 (product)
  On nil        reduce rule 16 (product)
  On >=         reduce rule 16 (product)
  On NUM        reduce rule 16 (product)
  On or         reduce rule 16 (product)
  On -          reduce rule 16 (product)
  On (          reduce rule 16 (product)
  On <          reduce rule 16 (product)
  On if         reduce rule 16 (product)
  On ,          reduce rule 16 (product)
  On ==         reduce rule 16 (product)
  On :          reduce rule 16 (product)
  On )          reduce rule 16 (product)
  On STR        reduce rule 16 (product)
  On ID         reduce rule 16 (product)
  On *          reduce rule 16 (product)
  On #[         reduce rule 16 (product)
  On <=         reduce rule 16 (product)
  On !=         reduce rule 16 (product)
  On ->         reduce rule 16 (product)
  On true       reduce rule 16 (product)

State 91
  product    → product "*" unary •

  On /          reduce rule 16 (product)
  On {          reduce rule 16 (product)
  On NL         reduce rule 16 (product)
  On in         reduce rule 16 (product)
  On cond       reduce rule 16 (product)
  On >          reduce rule 16 (product)
  On do         reduce rule 16 (product)
  On and        reduce rule 16 (product)
  On false      reduce rule 16 (product)
  On [          reduce rule 16 (product)
  On not        reduce rule 16 (product)
  On +          reduce rule 16 (product)
  On nil        reduce rule 16 (product)
  On >=         reduce rule 16 (product)
  On NUM        reduce rule 16 (product)
  On or         reduce rule 16 (product)
  On -          reduce rule 16 (product)
  On (          reduce rule 16 (product)
  On <          reduce rule 16 (product)
  On if         reduce rule 16 (product)
  On ,          reduce rule 16 (product)
  On ==         reduce rule 16 (product)
  On :          reduce rule 16 (product)
  On )          reduce rule 16 (product)
  On STR        reduce rule 16 (product)
  On ID         reduce rule 16 (product)
  On *          reduce rule 16 (product)
  On #[         reduce rule 16 (product)
  On <=         reduce rule 16 (product)
  On !=         reduce rule 16 (product)
  On ->         reduce rule 16 (product)
  On true       reduce rule 16 (product)

State 92
  list       → "[" items "]" •

  On /          reduce rule 31 (list)
  On {          reduce rule 31 (list)
  On NL         reduce rule 31 (list)
  On in         reduce rule 31 (list)
  On cond       reduce rule 31 (list)
  On >          reduce rule 31 (list)
  On do         reduce rule 31 (list)
  On and        reduce rule 31 (list)
  On false      reduce rule 31 (list)
  On [          reduce rule 31 (list)
  On not        reduce rule 31 (list)
  On +          reduce rule 31 (list)
  On nil        reduce rule 31 (list)
  On >=         reduce rule 31 (list)
  On NUM        reduce rule 31 (list)
  On or         reduce rule 31 (list)
  On -          reduce rule 31 (list)
  On (          reduce rule 31 (list)
  On <          reduce rule 31 (list)
  On if         reduce rule 31 (list)
  On ,          reduce rule 31 (list)
  On ==         reduce rule 31 (list)
  On :          reduce rule 31 (list)
  On )          reduce rule 31 (list)
  On STR        reduce rule 31 (list)
  On ID         reduce rule 31 (list)
  On *          reduce rule 31 (list)
  On #[         reduce rule 31 (list)
  On <=         reduce rule 31 (list)
  On !=         reduce rule 31 (list)
  On ->         reduce rule 31 (list)
  On true       reduce rule 31 (list)

State 93
  item       → arg • opt_comma
  opt_comma  → • ","
  opt_comma  → • NL
  opt_comma  → ε •

  On ]          reduce rule 38 (opt_comma)
  On (          reduce rule 38 (opt_comma)
  On {          reduce rule 38 (opt_comma)
  On NL         shift to state 116
  On if         reduce rule 38 (opt_comma)
  On ,          shift to state 117
  On cond       reduce rule 38 (opt_comma)
  On :          reduce rule 38 (opt_comma)
  On do         reduce rule 38 (opt_comma)
  On }          reduce rule 38 (opt_comma)
  On STR        reduce rule 38 (opt_comma)
  On false      reduce rule 38 (opt_comma)
  On ID         reduce rule 38 (opt_comma)
  On [          reduce rule 38 (opt_comma)
  On #[         reduce rule 38 (opt_comma)
  On not        reduce rule 38 (opt_comma)
  On nil        reduce rule 38 (opt_comma)
  On opt_comma  shift to state 118
  On NUM        reduce rule 38 (opt_comma)
  On true       reduce rule 38 (opt_comma)

State 94
  items      → items item •

  On ]          reduce rule 34 (items)
  On (          reduce rule 34 (items)
  On {          reduce rule 34 (items)
  On if         reduce rule 34 (items)
  On cond       reduce rule 34 (items)
  On :          reduce rule 34 (items)
  On do         reduce rule 34 (items)
  On STR        reduce rule 34 (items)
  On false      reduce rule 34 (items)
  On ID         reduce rule 34 (items)
  On [          reduce rule 34 (items)
  On #[         reduce rule 34 (items)
  On not        reduce rule 34 (items)
  On nil        reduce rule 34 (items)
  On NUM        reduce rule 34 (items)
  On true       reduce rule 34 (items)

State 95
  def_stmt   → "def" "(" id_list • ")" arg
  id_list    → id_list • ID

  On )          shift to state 119
  On ID         shift to state 120

State 96
  id_list    → ID •

  On )          reduce rule 7 (id_list)
  On ID         reduce rule 7 (id_list)

State 97
  assign     → ID "=" • call
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On call       shift to state 121
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 98
  assigns    → assigns "," • assign
  assign     → • ID "=" call

  On assign     shift to state 122
  On ID         shift to state 63

State 99
  access     → access "." ID •

  On /          reduce rule 21 (access)
  On {          reduce rule 21 (access)
  On NL         reduce rule 21 (access)
  On in         reduce rule 21 (access)
  On cond       reduce rule 21 (access)
  On >          reduce rule 21 (access)
  On do         reduce rule 21 (access)
  On and        reduce rule 21 (access)
  On false      reduce rule 21 (access)
  On [          reduce rule 21 (access)
  On not        reduce rule 21 (access)
  On +          reduce rule 21 (access)
  On nil        reduce rule 21 (access)
  On >=         reduce rule 21 (access)
  On NUM        reduce rule 21 (access)
  On or         reduce rule 21 (access)
  On -          reduce rule 21 (access)
  On (          reduce rule 21 (access)
  On <          reduce rule 21 (access)
  On if         reduce rule 21 (access)
  On ,          reduce rule 21 (access)
  On ==         reduce rule 21 (access)
  On :          reduce rule 21 (access)
  On )          reduce rule 21 (access)
  On STR        reduce rule 21 (access)
  On ID         reduce rule 21 (access)
  On *          reduce rule 21 (access)
  On #[         reduce rule 21 (access)
  On <=         reduce rule 21 (access)
  On !=         reduce rule 21 (access)
  On .          reduce rule 21 (access)
  On ->         reduce rule 21 (access)
  On true       reduce rule 21 (access)

State 100
  equals     → compare "==" compare •

  On (          reduce rule 12 (equals)
  On {          reduce rule 12 (equals)
  On NL         reduce rule 12 (equals)
  On if         reduce rule 12 (equals)
  On ,          reduce rule 12 (equals)
  On cond       reduce rule 12 (equals)
  On :          reduce rule 12 (equals)
  On do         reduce rule 12 (equals)
  On )          reduce rule 12 (equals)
  On STR        reduce rule 12 (equals)
  On and        reduce rule 12 (equals)
  On false      reduce rule 12 (equals)
  On ID         reduce rule 12 (equals)
  On [          reduce rule 12 (equals)
  On #[         reduce rule 12 (equals)
  On not        reduce rule 12 (equals)
  On nil        reduce rule 12 (equals)
  On NUM        reduce rule 12 (equals)
  On ->         reduce rule 12 (equals)
  On true       reduce rule 12 (equals)
  On or         reduce rule 12 (equals)

State 101
  equals     → compare "!=" compare •

  On (          reduce rule 12 (equals)
  On {          reduce rule 12 (equals)
  On NL         reduce rule 12 (equals)
  On if         reduce rule 12 (equals)
  On ,          reduce rule 12 (equals)
  On cond       reduce rule 12 (equals)
  On :          reduce rule 12 (equals)
  On do         reduce rule 12 (equals)
  On )          reduce rule 12 (equals)
  On STR        reduce rule 12 (equals)
  On and        reduce rule 12 (equals)
  On false      reduce rule 12 (equals)
  On ID         reduce rule 12 (equals)
  On [          reduce rule 12 (equals)
  On #[         reduce rule 12 (equals)
  On not        reduce rule 12 (equals)
  On nil        reduce rule 12 (equals)
  On NUM        reduce rule 12 (equals)
  On ->         reduce rule 12 (equals)
  On true       reduce rule 12 (equals)
  On or         reduce rule 12 (equals)

State 102
  group      → "(" call ")" •

  On /          reduce rule 22 (group)
  On {          reduce rule 22 (group)
  On NL         reduce rule 22 (group)
  On in         reduce rule 22 (group)
  On cond       reduce rule 22 (group)
  On >          reduce rule 22 (group)
  On do         reduce rule 22 (group)
  On and        reduce rule 22 (group)
  On false      reduce rule 22 (group)
  On [          reduce rule 22 (group)
  On not        reduce rule 22 (group)
  On +          reduce rule 22 (group)
  On nil        reduce rule 22 (group)
  On >=         reduce rule 22 (group)
  On NUM        reduce rule 22 (group)
  On or         reduce rule 22 (group)
  On -          reduce rule 22 (group)
  On (          reduce rule 22 (group)
  On <          reduce rule 22 (group)
  On if         reduce rule 22 (group)
  On ,          reduce rule 22 (group)
  On ==         reduce rule 22 (group)
  On :          reduce rule 22 (group)
  On )          reduce rule 22 (group)
  On STR        reduce rule 22 (group)
  On ID         reduce rule 22 (group)
  On *          reduce rule 22 (group)
  On #[         reduce rule 22 (group)
  On <=         reduce rule 22 (group)
  On !=         reduce rule 22 (group)
  On ->         reduce rule 22 (group)
  On true       reduce rule 22 (group)

State 103
  if_block   → "if" arg do_else •

  On /          reduce rule 25 (if_block)
  On {          reduce rule 25 (if_block)
  On NL         reduce rule 25 (if_block)
  On in         reduce rule 25 (if_block)
  On cond       reduce rule 25 (if_block)
  On >          reduce rule 25 (if_block)
  On do         reduce rule 25 (if_block)
  On and        reduce rule 25 (if_block)
  On false      reduce rule 25 (if_block)
  On [          reduce rule 25 (if_block)
  On not        reduce rule 25 (if_block)
  On +          reduce rule 25 (if_block)
  On nil        reduce rule 25 (if_block)
  On >=         reduce rule 25 (if_block)
  On NUM        reduce rule 25 (if_block)
  On or         reduce rule 25 (if_block)
  On -          reduce rule 25 (if_block)
  On (          reduce rule 25 (if_block)
  On <          reduce rule 25 (if_block)
  On if         reduce rule 25 (if_block)
  On ,          reduce rule 25 (if_block)
  On ==         reduce rule 25 (if_block)
  On :          reduce rule 25 (if_block)
  On )          reduce rule 25 (if_block)
  On STR        reduce rule 25 (if_block)
  On ID         reduce rule 25 (if_block)
  On *          reduce rule 25 (if_block)
  On #[         reduce rule 25 (if_block)
  On <=         reduce rule 25 (if_block)
  On !=         reduce rule 25 (if_block)
  On ->         reduce rule 25 (if_block)
  On true       reduce rule 25 (if_block)

State 104
  do_else    → "do" • stmts "else" stmts "end"
  stmts      → • stmts stmt NL
  stmts      → • NL
  stmts      → ε •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On NL         shift to state 1
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On stmts      shift to state 123
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 105
  lambda     → group "->" lambda •

  On (          reduce rule 10 (lambda)
  On {          reduce rule 10 (lambda)
  On NL         reduce rule 10 (lambda)
  On if         reduce rule 10 (lambda)
  On ,          reduce rule 10 (lambda)
  On cond       reduce rule 10 (lambda)
  On :          reduce rule 10 (lambda)
  On do         reduce rule 10 (lambda)
  On )          reduce rule 10 (lambda)
  On STR        reduce rule 10 (lambda)
  On false      reduce rule 10 (lambda)
  On ID         reduce rule 10 (lambda)
  On [          reduce rule 10 (lambda)
  On #[         reduce rule 10 (lambda)
  On not        reduce rule 10 (lambda)
  On nil        reduce rule 10 (lambda)
  On NUM        reduce rule 10 (lambda)
  On true       reduce rule 10 (lambda)

State 106
  access     → ID "." ID •

  On /          reduce rule 21 (access)
  On {          reduce rule 21 (access)
  On NL         reduce rule 21 (access)
  On in         reduce rule 21 (access)
  On cond       reduce rule 21 (access)
  On >          reduce rule 21 (access)
  On do         reduce rule 21 (access)
  On and        reduce rule 21 (access)
  On false      reduce rule 21 (access)
  On [          reduce rule 21 (access)
  On not        reduce rule 21 (access)
  On +          reduce rule 21 (access)
  On nil        reduce rule 21 (access)
  On >=         reduce rule 21 (access)
  On NUM        reduce rule 21 (access)
  On or         reduce rule 21 (access)
  On -          reduce rule 21 (access)
  On (          reduce rule 21 (access)
  On <          reduce rule 21 (access)
  On if         reduce rule 21 (access)
  On ,          reduce rule 21 (access)
  On ==         reduce rule 21 (access)
  On :          reduce rule 21 (access)
  On )          reduce rule 21 (access)
  On STR        reduce rule 21 (access)
  On ID         reduce rule 21 (access)
  On *          reduce rule 21 (access)
  On #[         reduce rule 21 (access)
  On <=         reduce rule 21 (access)
  On !=         reduce rule 21 (access)
  On .          reduce rule 21 (access)
  On ->         reduce rule 21 (access)
  On true       reduce rule 21 (access)

State 107
  compare    → member "<" member •

  On (          reduce rule 13 (compare)
  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On do         reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On !=         reduce rule 13 (compare)
  On NUM        reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)
  On or         reduce rule 13 (compare)

State 108
  compare    → member ">" member •

  On (          reduce rule 13 (compare)
  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On do         reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On !=         reduce rule 13 (compare)
  On NUM        reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)
  On or         reduce rule 13 (compare)

State 109
  compare    → member "<=" member •

  On (          reduce rule 13 (compare)
  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On do         reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On !=         reduce rule 13 (compare)
  On NUM        reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)
  On or         reduce rule 13 (compare)

State 110
  compare    → member ">=" member •

  On (          reduce rule 13 (compare)
  On {          reduce rule 13 (compare)
  On NL         reduce rule 13 (compare)
  On if         reduce rule 13 (compare)
  On ,          reduce rule 13 (compare)
  On cond       reduce rule 13 (compare)
  On ==         reduce rule 13 (compare)
  On :          reduce rule 13 (compare)
  On do         reduce rule 13 (compare)
  On )          reduce rule 13 (compare)
  On STR        reduce rule 13 (compare)
  On and        reduce rule 13 (compare)
  On false      reduce rule 13 (compare)
  On ID         reduce rule 13 (compare)
  On [          reduce rule 13 (compare)
  On #[         reduce rule 13 (compare)
  On not        reduce rule 13 (compare)
  On nil        reduce rule 13 (compare)
  On !=         reduce rule 13 (compare)
  On NUM        reduce rule 13 (compare)
  On ->         reduce rule 13 (compare)
  On true       reduce rule 13 (compare)
  On or         reduce rule 13 (compare)

State 111
  tuple      → "#[" items "]" •

  On /          reduce rule 32 (tuple)
  On {          reduce rule 32 (tuple)
  On NL         reduce rule 32 (tuple)
  On in         reduce rule 32 (tuple)
  On cond       reduce rule 32 (tuple)
  On >          reduce rule 32 (tuple)
  On do         reduce rule 32 (tuple)
  On and        reduce rule 32 (tuple)
  On false      reduce rule 32 (tuple)
  On [          reduce rule 32 (tuple)
  On not        reduce rule 32 (tuple)
  On +          reduce rule 32 (tuple)
  On nil        reduce rule 32 (tuple)
  On >=         reduce rule 32 (tuple)
  On NUM        reduce rule 32 (tuple)
  On or         reduce rule 32 (tuple)
  On -          reduce rule 32 (tuple)
  On (          reduce rule 32 (tuple)
  On <          reduce rule 32 (tuple)
  On if         reduce rule 32 (tuple)
  On ,          reduce rule 32 (tuple)
  On ==         reduce rule 32 (tuple)
  On :          reduce rule 32 (tuple)
  On )          reduce rule 32 (tuple)
  On STR        reduce rule 32 (tuple)
  On ID         reduce rule 32 (tuple)
  On *          reduce rule 32 (tuple)
  On #[         reduce rule 32 (tuple)
  On <=         reduce rule 32 (tuple)
  On !=         reduce rule 32 (tuple)
  On ->         reduce rule 32 (tuple)
  On true       reduce rule 32 (tuple)

State 112
  entry      → ID ":" • arg opt_comma
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 124
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 113
  clause     → logic • "->" call NL
  logic      → logic • "and" equals
  logic      → logic • "or" equals

  On and        shift to state 51
  On ->         shift to state 125
  On or         shift to state 52

State 114
  clauses    → clauses clause •

  On (          reduce rule 28 (clauses)
  On {          reduce rule 28 (clauses)
  On if         reduce rule 28 (clauses)
  On cond       reduce rule 28 (clauses)
  On :          reduce rule 28 (clauses)
  On do         reduce rule 28 (clauses)
  On STR        reduce rule 28 (clauses)
  On false      reduce rule 28 (clauses)
  On ID         reduce rule 28 (clauses)
  On [          reduce rule 28 (clauses)
  On #[         reduce rule 28 (clauses)
  On not        reduce rule 28 (clauses)
  On end        reduce rule 28 (clauses)
  On nil        reduce rule 28 (clauses)
  On NUM        reduce rule 28 (clauses)
  On true       reduce rule 28 (clauses)

State 115
  cond_block → "cond" "do" clauses "end" •

  On /          reduce rule 27 (cond_block)
  On {          reduce rule 27 (cond_block)
  On NL         reduce rule 27 (cond_block)
  On in         reduce rule 27 (cond_block)
  On cond       reduce rule 27 (cond_block)
  On >          reduce rule 27 (cond_block)
  On do         reduce rule 27 (cond_block)
  On and        reduce rule 27 (cond_block)
  On false      reduce rule 27 (cond_block)
  On [          reduce rule 27 (cond_block)
  On not        reduce rule 27 (cond_block)
  On +          reduce rule 27 (cond_block)
  On nil        reduce rule 27 (cond_block)
  On >=         reduce rule 27 (cond_block)
  On NUM        reduce rule 27 (cond_block)
  On or         reduce rule 27 (cond_block)
  On -          reduce rule 27 (cond_block)
  On (          reduce rule 27 (cond_block)
  On <          reduce rule 27 (cond_block)
  On if         reduce rule 27 (cond_block)
  On ,          reduce rule 27 (cond_block)
  On ==         reduce rule 27 (cond_block)
  On :          reduce rule 27 (cond_block)
  On )          reduce rule 27 (cond_block)
  On STR        reduce rule 27 (cond_block)
  On ID         reduce rule 27 (cond_block)
  On *          reduce rule 27 (cond_block)
  On #[         reduce rule 27 (cond_block)
  On <=         reduce rule 27 (cond_block)
  On !=         reduce rule 27 (cond_block)
  On ->         reduce rule 27 (cond_block)
  On true       reduce rule 27 (cond_block)

State 116
  opt_comma  → NL •

  On ]          reduce rule 38 (opt_comma)
  On (          reduce rule 38 (opt_comma)
  On {          reduce rule 38 (opt_comma)
  On if         reduce rule 38 (opt_comma)
  On cond       reduce rule 38 (opt_comma)
  On :          reduce rule 38 (opt_comma)
  On do         reduce rule 38 (opt_comma)
  On }          reduce rule 38 (opt_comma)
  On STR        reduce rule 38 (opt_comma)
  On false      reduce rule 38 (opt_comma)
  On ID         reduce rule 38 (opt_comma)
  On [          reduce rule 38 (opt_comma)
  On #[         reduce rule 38 (opt_comma)
  On not        reduce rule 38 (opt_comma)
  On nil        reduce rule 38 (opt_comma)
  On NUM        reduce rule 38 (opt_comma)
  On true       reduce rule 38 (opt_comma)

State 117
  opt_comma  → "," •

  On ]          reduce rule 38 (opt_comma)
  On (          reduce rule 38 (opt_comma)
  On {          reduce rule 38 (opt_comma)
  On if         reduce rule 38 (opt_comma)
  On cond       reduce rule 38 (opt_comma)
  On :          reduce rule 38 (opt_comma)
  On do         reduce rule 38 (opt_comma)
  On }          reduce rule 38 (opt_comma)
  On STR        reduce rule 38 (opt_comma)
  On false      reduce rule 38 (opt_comma)
  On ID         reduce rule 38 (opt_comma)
  On [          reduce rule 38 (opt_comma)
  On #[         reduce rule 38 (opt_comma)
  On not        reduce rule 38 (opt_comma)
  On nil        reduce rule 38 (opt_comma)
  On NUM        reduce rule 38 (opt_comma)
  On true       reduce rule 38 (opt_comma)

State 118
  item       → arg opt_comma •

  On ]          reduce rule 35 (item)
  On (          reduce rule 35 (item)
  On {          reduce rule 35 (item)
  On if         reduce rule 35 (item)
  On cond       reduce rule 35 (item)
  On :          reduce rule 35 (item)
  On do         reduce rule 35 (item)
  On STR        reduce rule 35 (item)
  On false      reduce rule 35 (item)
  On ID         reduce rule 35 (item)
  On [          reduce rule 35 (item)
  On #[         reduce rule 35 (item)
  On not        reduce rule 35 (item)
  On nil        reduce rule 35 (item)
  On NUM        reduce rule 35 (item)
  On true       reduce rule 35 (item)

State 119
  def_stmt   → "def" "(" id_list ")" • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 126
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 120
  id_list    → id_list ID •

  On )          reduce rule 7 (id_list)
  On ID         reduce rule 7 (id_list)

State 121
  assign     → ID "=" call •
  call       → call • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On NL         reduce rule 5 (assign)
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 61
  On if         shift to state 30
  On ,          reduce rule 5 (assign)
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 122
  assigns    → assigns "," assign •

  On NL         reduce rule 4 (assigns)
  On ,          reduce rule 4 (assigns)

State 123
  do_else    → "do" stmts • "else" stmts "end"
  stmts      → stmts • stmt NL
  stmt       → • let_stmt
  stmt       → • def_stmt
  stmt       → • call
  let_stmt   → • "let" assigns
  def_stmt   → • "def" "(" id_list ")" arg
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On literal    shift to state 3
  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On let_stmt   shift to state 13
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On def        shift to state 17
  On not        shift to state 18
  On call       shift to state 19
  On if_block   shift to state 20
  On let        shift to state 21
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On else       shift to state 127
  On lambda     shift to state 40
  On cond_block shift to state 41
  On def_stmt   shift to state 42
  On block      shift to state 43
  On tuple      shift to state 44
  On stmt       shift to state 45
  On true       shift to state 46

State 124
  entry      → ID ":" arg • opt_comma
  opt_comma  → • ","
  opt_comma  → • NL
  opt_comma  → ε •

  On ]          reduce rule 38 (opt_comma)
  On (          reduce rule 38 (opt_comma)
  On {          reduce rule 38 (opt_comma)
  On NL         shift to state 116
  On if         reduce rule 38 (opt_comma)
  On ,          shift to state 117
  On cond       reduce rule 38 (opt_comma)
  On :          reduce rule 38 (opt_comma)
  On do         reduce rule 38 (opt_comma)
  On }          reduce rule 38 (opt_comma)
  On STR        reduce rule 38 (opt_comma)
  On false      reduce rule 38 (opt_comma)
  On ID         reduce rule 38 (opt_comma)
  On [          reduce rule 38 (opt_comma)
  On #[         reduce rule 38 (opt_comma)
  On not        reduce rule 38 (opt_comma)
  On nil        reduce rule 38 (opt_comma)
  On opt_comma  shift to state 128
  On NUM        reduce rule 38 (opt_comma)
  On true       reduce rule 38 (opt_comma)

State 125
  clause     → logic "->" • call NL
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On call       shift to state 129
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 126
  def_stmt   → "def" "(" id_list ")" arg •

  On NL         reduce rule 6 (def_stmt)

State 127
  do_else    → "do" stmts "else" • stmts "end"
  stmts      → • stmts stmt NL
  stmts      → • NL
  stmts      → ε •

  On (          reduce rule 1 (stmts)
  On {          reduce rule 1 (stmts)
  On NL         shift to state 1
  On if         reduce rule 1 (stmts)
  On cond       reduce rule 1 (stmts)
  On :          reduce rule 1 (stmts)
  On do         reduce rule 1 (stmts)
  On stmts      shift to state 130
  On STR        reduce rule 1 (stmts)
  On false      reduce rule 1 (stmts)
  On ID         reduce rule 1 (stmts)
  On [          reduce rule 1 (stmts)
  On def        reduce rule 1 (stmts)
  On #[         reduce rule 1 (stmts)
  On not        reduce rule 1 (stmts)
  On $          reduce rule 1 (stmts)
  On end        reduce rule 1 (stmts)
  On let        reduce rule 1 (stmts)
  On else       reduce rule 1 (stmts)
  On nil        reduce rule 1 (stmts)
  On NUM        reduce rule 1 (stmts)
  On true       reduce rule 1 (stmts)

State 128
  entry      → ID ":" arg opt_comma •

  On }          reduce rule 37 (entry)
  On ID         reduce rule 37 (entry)

State 129
  clause     → logic "->" call • NL
  call       → call • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On NL         shift to state 131
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On not        shift to state 18
  On if_block   shift to state 20
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 61
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On block      shift to state 43
  On tuple      shift to state 44
  On true       shift to state 46
  On literal    shift to state 3

State 130
  do_else    → "do" stmts "else" stmts • "end"
  stmts      → stmts • stmt NL
  stmt       → • let_stmt
  stmt       → • def_stmt
  stmt       → • call
  let_stmt   → • "let" assigns
  def_stmt   → • "def" "(" id_list ")" arg
  call       → • call arg
  call       → • arg
  arg        → • lambda
  lambda     → • group "->" lambda
  lambda     → • logic
  group      → • "(" call ")"
  logic      → • logic "and" equals
  logic      → • logic "or" equals
  logic      → • equals
  equals     → • compare "==" compare
  equals     → • compare "!=" compare
  equals     → • compare
  compare    → • member ">" member
  compare    → • member ">=" member
  compare    → • member "<" member
  compare    → • member "<=" member
  compare    → • member
  member     → • sum "in" sum
  member     → • sum
  sum        → • sum "+" product
  sum        → • sum "-" product
  sum        → • product
  product    → • product "*" unary
  product    → • product "/" unary
  product    → • unary
  unary      → • "not" primary
  unary      → • primary
  primary    → • NUM
  primary    → • ID
  primary    → • STR
  primary    → • literal
  primary    → • symbol
  primary    → • access
  primary    → • group
  primary    → • block
  primary    → • object
  literal    → • "true"
  literal    → • "false"
  literal    → • "nil"
  symbol     → • ":" ID
  access     → • access "." ID
  access     → • ID "." ID
  block      → • do_block
  block      → • if_block
  block      → • cond_block
  object     → • list
  object     → • tuple
  object     → • map
  do_block   → • "do" stmts "end"
  if_block   → • "if" arg do_else
  cond_block → • "cond" "do" clauses "end"
  list       → • "[" items "]"
  tuple      → • "#[" items "]"
  map        → • "{" entries "}"

  On literal    shift to state 3
  On sum        shift to state 4
  On {          shift to state 5
  On do_block   shift to state 6
  On logic      shift to state 7
  On cond       shift to state 8
  On symbol     shift to state 9
  On do         shift to state 10
  On product    shift to state 11
  On map        shift to state 12
  On let_stmt   shift to state 13
  On false      shift to state 14
  On equals     shift to state 15
  On [          shift to state 16
  On def        shift to state 17
  On not        shift to state 18
  On end        shift to state 132
  On call       shift to state 19
  On if_block   shift to state 20
  On let        shift to state 21
  On nil        shift to state 22
  On access     shift to state 23
  On NUM        shift to state 24
  On unary      shift to state 25
  On compare    shift to state 26
  On object     shift to state 27
  On (          shift to state 28
  On arg        shift to state 29
  On if         shift to state 30
  On :          shift to state 31
  On group      shift to state 32
  On STR        shift to state 33
  On primary    shift to state 34
  On ID         shift to state 35
  On member     shift to state 36
  On #[         shift to state 37
  On list       shift to state 38
  On lambda     shift to state 40
  On cond_block shift to state 41
  On def_stmt   shift to state 42
  On block      shift to state 43
  On tuple      shift to state 44
  On stmt       shift to state 45
  On true       shift to state 46

State 131
  clause     → logic "->" call NL •

  On (          reduce rule 29 (clause)
  On {          reduce rule 29 (clause)
  On if         reduce rule 29 (clause)
  On cond       reduce rule 29 (clause)
  On :          reduce rule 29 (clause)
  On do         reduce rule 29 (clause)
  On STR        reduce rule 29 (clause)
  On false      reduce rule 29 (clause)
  On ID         reduce rule 29 (clause)
  On [          reduce rule 29 (clause)
  On #[         reduce rule 29 (clause)
  On not        reduce rule 29 (clause)
  On end        reduce rule 29 (clause)
  On nil        reduce rule 29 (clause)
  On NUM        reduce rule 29 (clause)
  On true       reduce rule 29 (clause)

State 132
  do_else    → "do" stmts "else" stmts "end" •

  On /          reduce rule 26 (do_else)
  On {          reduce rule 26 (do_else)
  On NL         reduce rule 26 (do_else)
  On in         reduce rule 26 (do_else)
  On cond       reduce rule 26 (do_else)
  On >          reduce rule 26 (do_else)
  On do         reduce rule 26 (do_else)
  On and        reduce rule 26 (do_else)
  On false      reduce rule 26 (do_else)
  On [          reduce rule 26 (do_else)
  On not        reduce rule 26 (do_else)
  On +          reduce rule 26 (do_else)
  On nil        reduce rule 26 (do_else)
  On >=         reduce rule 26 (do_else)
  On NUM        reduce rule 26 (do_else)
  On or         reduce rule 26 (do_else)
  On -          reduce rule 26 (do_else)
  On (          reduce rule 26 (do_else)
  On <          reduce rule 26 (do_else)
  On if         reduce rule 26 (do_else)
  On ,          reduce rule 26 (do_else)
  On ==         reduce rule 26 (do_else)
  On :          reduce rule 26 (do_else)
  On )          reduce rule 26 (do_else)
  On STR        reduce rule 26 (do_else)
  On ID         reduce rule 26 (do_else)
  On *          reduce rule 26 (do_else)
  On #[         reduce rule 26 (do_else)
  On <=         reduce rule 26 (do_else)
  On !=         reduce rule 26 (do_else)
  On ->         reduce rule 26 (do_else)
  On true       reduce rule 26 (do_else)

