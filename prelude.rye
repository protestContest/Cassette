def (identity x) do x end

def (reverse-onto list rest) do
  if list == nil do
    rest
  else
    reverse-onto (tail list) [(head list) | rest]
  end
end

def (reverse list) do
  reverse-onto list nil
end

def (append list1 list2) do
  reverse-onto (reverse list1) list2
end

def (prepend list1 list2) do append list2 list1 end

def (reduce list acc fn) do
  if list == nil do
    acc
  else
    reduce (tail list) (fn (head list) acc) fn
  end
end

def (filter list fn) do
  reverse (reduce list nil (item acc) ->
    if (fn item) do
      [item | acc]
    else
      acc
    end)
end

def (reject list fn) do
  reverse (reduce list nil (item acc) ->
    if (fn item) do
      acc
    else
      [item | acc]
    end)
end

def (map list fn) do
  reverse (reduce list nil (item acc) -> [(fn item) | acc])
end

def (each list fn) do
  reduce list nil (item acc) -> do
    (fn item)
    nil
  end
end

def (flatten lists) do
  reduce (reverse lists) nil (item acc) ->
    if (list? item) do
      append item result
    else
      [item | result]
    end
end

def (flatmap list fn) do
  flatten (map list fn)
end

def (tail-from list n) do
  cond do
    list == nil :: nil
    n <= 0 :: list
    true :: tail-from (tail list) n - 1
  end
end

def (length list) do
  def (loop list count) do
    if list == nil do
      count
    else
      loop (tail list) n + 1
    end
  end

  loop list 0
end

def (truncate list n) do
  let to_delete = (length list) - n
  reverse (tail-from (reverse list) to_delete)
end

def (slice list a b) do
  truncate (tail-from list a) b - a
end

def (split-at list i) do
  [(slice list 0 i) | (slice list i (length list))]
end

def (sort list compare) do
  def (merge list1 list2 merged) do
    cond do
      list1 == nil and list2 == nil :: reverse merged
      list1 == nil :: merge list1 (tail list2) [(head list2) | merged]
      list2 == nil :: merge (tail list1) list2 [(head list1) | merged]
      compare (head list1) (head list2) :: merge (tail list1) list2 [(head list1) | merged]
      true :: merge list1 (tail list2) [(head list2) | merged]
    end
  end

  if (length list) <= 1 do
    list
  else
    let i = div (length list) 2,
        sublists = split-at list i
    merge (sort (head sublists) compare) (sort (tail sublists) compare) nil
  end
end

def (in-list? item list) do
  cond do
    list == nil :: false
    (head list) == item :: true
    true :: in-list? item (tail list)
  end
end

def (unique list) do
  reverse (reduce list nil (item acc) ->
    if (in-list? item acc) do
      acc
    else
      [item | acc]
    end)
end

def (with-index list) do
  reverse (reduce list nil (item indexed) -> do
    let i = if indexed == nil do 0 else (head (head indexed)) + 1 end
    [[i | item] | indexed]
  end)
end

def (nth list n) do
  cond do
    list == nil :: nil
    n == 0 :: head list
    true :: nth (tail list) n - 1
  end
end

def (first list) do nth 0 list end
def (second list) do nth 1 list end
def (third list) do nth 2 list end
def (fourth list) do nth 3 list end
def (fifth list) do nth 4 list end
def (sixth list) do nth 5 list end
def (seventh list) do nth 6 list end
def (eighth list) do nth 7 list end

def (find list fn) do
  cond do
    list == nil :: nil
    (fn (head list)) :: head list
    true :: find (tail list) fn
  end
end

def (find-index list fn) do
  def (loop list index) do
    cond do
      list == nil :: nil
      (fn (head list)) :: index
      true :: loop (tail list) index + 1
    end
  end

  loop list 0
end

def (find-value list fn) do
  if list == nil do
    nil
  else
    let value = fn (head list)
    if value == nil do
      find-value (tail list) fn
    else
      value
    end
  end
end

def (index-of item list) do
  find-index list (list-item) -> list-item == item
end

def (chunk-every items n) do
  def (chunk-loop items chunk n) do
    if items == nil or (length chunk) >= n do
      [items | (reverse chunk)]
    else
      chunk-loop (tail items) [(head items) | chunk] n
    end
  end

  def (chunks-loop items chunks n) do
    if items == nil do
      reverse chunks
    else
      let result = chunk-loop items nil n,
          items = head result,
          chunk = tail result

      chunks-loop items [chunk | chunks] n
    end
  end

  chunks-loop items nil n
end

def (zip list1 list2) do
  def (loop list1 list2 zipped) do
    if list1 == nil and list2 == nil do
      zipped
    else
      loop (tail list1) (tail list2) [[(head list1) | (head list2)] | zipped]
    end
  end

  reverse (loop list1 list2 nil)
end

def (unzip pairs) do
  reduce (reverse pairs) [nil nil] (pair unzipped) -> do
    let heads = first unzipped, tails = second unzipped
    [[(head pair) | heads] [(tail pair) | tails]]
  end
end

def (join list sep) do
  if list == nil do
    nil
  else
    reduce (tail list) (to-string (head list)) (item str) ->
      string-append (string-append str sep) (to-string item)
  end
end
